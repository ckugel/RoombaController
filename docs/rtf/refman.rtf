{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;\red0\green128\blue0;\red96\green64\blue32;\rede0\green128\blue0;\red128\green0\blue0;\red128\green96\blue32;\red0\green32\blue128;\red0\green128\blue128;\red255\green0\blue255;\red0\green0\blue0;\red112\green0\blue112;\red255\green0\blue0;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext50 Code Example 9;}
{\s50\li3600\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext51 Code Example 10;}
{\s51\li3960\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext52 Code Example 11;}
{\s52\li4320\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 12;}
{\s53\li4680\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 13;}
{\s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext61 List Continue 0;}
{\s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext62 List Continue 1;}
{\s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext63 List Continue 2;}
{\s63\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext64 List Continue 3;}
{\s64\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext65 List Continue 4;}
{\s65\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext66 List Continue 5;}
{\s66\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext67 List Continue 6;}
{\s67\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext68 List Continue 7;}
{\s68\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext69 List Continue 8;}
{\s69\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext70 List Continue 9;}
{\s70\li3600\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext71 List Continue 10;}
{\s71\li3960\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext72 List Continue 11;}
{\s72\li4320\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 12;}
{\s73\li4680\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 13;}
{\s80\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext81 DescContinue 0;}
{\s81\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext82 DescContinue 1;}
{\s82\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext83 DescContinue 2;}
{\s83\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext84 DescContinue 3;}
{\s84\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext85 DescContinue 4;}
{\s85\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext86 DescContinue 5;}
{\s86\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext87 DescContinue 6;}
{\s87\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext88 DescContinue 7;}
{\s88\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext89 DescContinue 8;}
{\s89\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext90 DescContinue 9;}
{\s90\li3600\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext91 DescContinue 10;}
{\s91\li3960\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext92 DescContinue 11;}
{\s92\li4320\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 12;}
{\s93\li4680\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 13;}
{\s100\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext101 LatexTOC 0;}
{\s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext102 LatexTOC 1;}
{\s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext103 LatexTOC 2;}
{\s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext104 LatexTOC 3;}
{\s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext105 LatexTOC 4;}
{\s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext106 LatexTOC 5;}
{\s106\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext107 LatexTOC 6;}
{\s107\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext108 LatexTOC 7;}
{\s108\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext109 LatexTOC 8;}
{\s109\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext110 LatexTOC 9;}
{\s110\li3600\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext111 LatexTOC 10;}
{\s111\li3960\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext112 LatexTOC 11;}
{\s112\li4320\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 12;}
{\s113\li4680\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 13;}
{\s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext121 \sautoupd List Bullet 0;}
{\s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext122 \sautoupd List Bullet 1;}
{\s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext123 \sautoupd List Bullet 2;}
{\s123\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext124 \sautoupd List Bullet 3;}
{\s124\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext125 \sautoupd List Bullet 4;}
{\s125\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext126 \sautoupd List Bullet 5;}
{\s126\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext127 \sautoupd List Bullet 6;}
{\s127\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext128 \sautoupd List Bullet 7;}
{\s128\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext129 \sautoupd List Bullet 8;}
{\s129\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext130 \sautoupd List Bullet 9;}
{\s130\fi-360\li3960\widctlpar\jclisttab\tx3960{\*\pn \pnlvlbody\ilvl0\ls11\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext131 \sautoupd List Bullet 10;}
{\s131\fi-360\li4320\widctlpar\jclisttab\tx4320{\*\pn \pnlvlbody\ilvl0\ls12\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext132 \sautoupd List Bullet 11;}
{\s132\fi-360\li4680\widctlpar\jclisttab\tx4680{\*\pn \pnlvlbody\ilvl0\ls13\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 12;}
{\s133\fi-360\li5040\widctlpar\jclisttab\tx5040{\*\pn \pnlvlbody\ilvl0\ls14\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 13;}
{\s140\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext141 \sautoupd List Enum 0;}
{\s141\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext142 \sautoupd List Enum 1;}
{\s142\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext143 \sautoupd List Enum 2;}
{\s143\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext144 \sautoupd List Enum 3;}
{\s144\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext145 \sautoupd List Enum 4;}
{\s145\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext146 \sautoupd List Enum 5;}
{\s146\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext147 \sautoupd List Enum 6;}
{\s147\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext148 \sautoupd List Enum 7;}
{\s148\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext149 \sautoupd List Enum 8;}
{\s149\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext150 \sautoupd List Enum 9;}
{\s150\fi-360\li3960\widctlpar\fs20\cgrid \sbasedon0 \snext151 \sautoupd List Enum 10;}
{\s151\fi-360\li4320\widctlpar\fs20\cgrid \sbasedon0 \snext152 \sautoupd List Enum 11;}
{\s152\fi-360\li4680\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 12;}
{\s153\fi-360\li5040\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 13;}
}
{\info 
{\title {\comment Roomba Controller Dashboard  {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
1 \par
}}Roomba Controller Dashboard}
{\comment Generated by doxygen 1.10.0.}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt Roomba Controller Dashboard}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Version 1\par\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Table of Contents\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Index\par \pard\plain 
{\tc \v Class Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Class List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here are the classes, structs, unions and interfaces with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b Graph< V >::CustomCompare} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Field} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Graph< V >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Hole} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b HoleManager} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Move} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Node< V >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Pillar} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Pose2D} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Rectangle} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Index\par \pard\plain 
{\tc \v File Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
File List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all files with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b /home/calebk/Documents/coding/RoombaController/src/{\b Field.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/calebk/Documents/coding/RoombaController/src/{\b Field.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/calebk/Documents/coding/RoombaController/src/{\b Graph.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/calebk/Documents/coding/RoombaController/src/{\b Graph.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/calebk/Documents/coding/RoombaController/src/{\b Hole.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/calebk/Documents/coding/RoombaController/src/{\b Hole.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/calebk/Documents/coding/RoombaController/src/{\b HoleManager.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/calebk/Documents/coding/RoombaController/src/{\b HoleManager.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/calebk/Documents/coding/RoombaController/src/{\b main.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/calebk/Documents/coding/RoombaController/src/{\b Node.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/calebk/Documents/coding/RoombaController/src/{\b Node.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/calebk/Documents/coding/RoombaController/src/{\b Pillar.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/calebk/Documents/coding/RoombaController/src/{\b Pillar.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/calebk/Documents/coding/RoombaController/src/{\b Pose2D.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/calebk/Documents/coding/RoombaController/src/{\b Pose2D.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/calebk/Documents/coding/RoombaController/src/{\b util.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /home/calebk/Documents/coding/RoombaController/src/{\b util.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Documentation{\tc \v Class Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Graph< V >::CustomCompare Struct Reference\par \pard\plain 
{\tc\tcl2 \v Graph< V >::CustomCompare}
{\xe \v Graph< V >::CustomCompare}
{\bkmkstart AAAAAAAAFS}
{\bkmkend AAAAAAAAFS}
\par
{
{\f2 #include <Graph.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b operator()} ({\b const} {\b pair} &{\b first}, {\b const} {\b pair} &{\b second})\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<{\b typename} {\b V}>\par
struct Graph< V >::CustomCompare\par
}
\par
{
Definition at line {\b 20} of file {\b Graph.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v operator()\:Graph< V >::CustomCompare}
{\xe \v Graph< V >::CustomCompare\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b typename} {\b V} > {\b bool} {\b Graph}< {\b V} >::CustomCompare::operator() ({\b const} {\b pair} &  {\i first}, {\b const} {\b pair} &  {\i second}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFT}
{\bkmkend AAAAAAAAFT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 21} of file {\b Graph.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/home/calebk/Documents/coding/RoombaController/src/{\b Graph.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Field Class Reference\par \pard\plain 
{\tc\tcl2 \v Field}
{\xe \v Field}
{\bkmkstart AAAAAAAADJ}
{\bkmkend AAAAAAAADJ}
\par
{
{\f2 #include <Field.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Field} (const std::vector< {\b Pillar} > &{\b pillars}, const {\b Pose2D} &{\b desiredDestination}, const {\b Pillar} &{\b botPose})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Field} (const std::vector< {\b Pillar} > &{\b pillars}, const {\b Pose2D} &{\b desiredDestination})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Field} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Field} (const std::unique_ptr< std::vector< {\b Pillar} > > &{\b pillars}, const {\b Pose2D} &desired_destination, const {\b Pillar} &bot_pose, const {\b Graph}< {\b Pose2D} > &{\b graph})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addEdgeMeasurement} (double rawPosition, {\b Cardinality} cardinality)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b HoleManager} & {\b getManager} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b applyOffsetToEdge} (double x, double y)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int32_t {\b getDesiredIndex} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b clearField} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Graph}< {\b Pose2D} > & {\b getGraph} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Pillar} {\b getBotPose} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b discretizeGraph} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b weightGraph} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b Pose2D} > {\b makePath} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addPillar} ({\b Pillar} &newPillar)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b updateBotPose} (const {\b Pose2D} &updatedPosition)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::unique_ptr< std::vector< {\b Pillar} > > {\b getPillars} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPillars} (std::unique_ptr< std::vector< {\b Pillar} > > {\b pillars})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b Pillar} > {\b getCopyPillars} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b validLocationForNode} (const {\b Pose2D} &location)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Pose2D} {\b getDesiredDestination} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b updateDesired} (const {\b Pose2D} &other)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setDesiredIndex} (int32_t index)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static bool {\b outOfBounds} (const {\b Pose2D} &location)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static bool {\b lineIntersectsCircle} (double cx, double cy, double r, double x1, double y1, double x2, double y2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static bool {\b lineIntersectsCircle} ({\b Pillar} p1, const {\b Pose2D} &one, const {\b Pose2D} &two)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static double {\b roundRadius} (double radius)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::unique_ptr< std::vector< {\b Pillar} > > {\b pillars}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b HoleManager} {\b holeManager}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Pose2D} {\b offset}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Pose2D} {\b desiredDestination}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Pillar} {\b botPose}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Pose2D} {\b runningError}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Graph}< {\b Pose2D} > {\b graph}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int32_t {\b desiredIndex} = -1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b Pillar} > {\b newPillars}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A class that represents the objects that can be and are on the field \par
}{
Definition at line {\b 40} of file {\b Field.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Field\:Field}
{\xe \v Field\:Field}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Field::Field (const std::vector< {\b Pillar} > &  {\i pillars}, const {\b Pose2D} &  {\i desiredDestination}, const {\b Pillar} &  {\i botPose})}}
\par
{\bkmkstart AAAAAAAADK}
{\bkmkend AAAAAAAADK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
constructs a new field object {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pillars} \cell }{the pillars that the field stores \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i desiredDestination} \cell }{the desired destination for the app to generate a path to \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i botPose} \cell }{\cell }
{\row }
}
}{
Definition at line {\b 7} of file {\b Field.cpp}.}\par
}
{\xe \v Field\:Field}
{\xe \v Field\:Field}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Field::Field (const std::vector< {\b Pillar} > &  {\i pillars}, const {\b Pose2D} &  {\i desiredDestination})}}
\par
{\bkmkstart AAAAAAAADL}
{\bkmkend AAAAAAAADL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
constructs a new field object {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pillars} \cell }{the pillars that the field stores \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i desiredDestination} \cell }{the desired destination for the app to generate a path to \cell }
{\row }
}
}{
Definition at line {\b 16} of file {\b Field.cpp}.}\par
}
{\xe \v Field\:Field}
{\xe \v Field\:Field}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Field::Field ()}}
\par
{\bkmkstart AAAAAAAADM}
{\bkmkend AAAAAAAADM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs a deafult field object \par
}{
Definition at line {\b 24} of file {\b Field.cpp}.}\par
}
{\xe \v Field\:Field}
{\xe \v Field\:Field}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Field::Field (const std::unique_ptr< std::vector< {\b Pillar} > > &  {\i pillars}, const {\b Pose2D} &  {\i desired_destination}, const {\b Pillar} &  {\i bot_pose}, const {\b Graph}< {\b Pose2D} > &  {\i graph})}}
\par
{\bkmkstart AAAAAAAADN}
{\bkmkend AAAAAAAADN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copys the majority of the important parts of the field {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pillars} \cell }{the pillars to store \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i desired_destination} \cell }{the desired destination to travel to \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i bot_pose} \cell }{the bot position \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i graph} \cell }{the graph object \cell }
{\row }
}
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addEdgeMeasurement\:Field}
{\xe \v Field\:addEdgeMeasurement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Field::addEdgeMeasurement (double  {\i rawPosition}, {\b Cardinality}  {\i cardinality})}}
\par
{\bkmkstart AAAAAAAADO}
{\bkmkend AAAAAAAADO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add an edge measurement to the field. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i rawPosition} \cell }{the raw position (X or Y) of the measurmenet \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i cardinality} \cell }{the direction of the measurement \cell }
{\row }
}
}{
Definition at line {\b 203} of file {\b Field.cpp}.}\par
}
{\xe \v addPillar\:Field}
{\xe \v Field\:addPillar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Field::addPillar ({\b Pillar} &  {\i newPillar})}}
\par
{\bkmkstart AAAAAAAADP}
{\bkmkend AAAAAAAADP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a pillar measurement to the graph {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i newPillar} \cell }{to add \cell }
{\row }
}
}{
Definition at line {\b 159} of file {\b Field.cpp}.}\par
}
{\xe \v applyOffsetToEdge\:Field}
{\xe \v Field\:applyOffsetToEdge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Field::applyOffsetToEdge (double  {\i x}, double  {\i y})}}
\par
{\bkmkstart AAAAAAAADQ}
{\bkmkend AAAAAAAADQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Applys some offset from getting the edge of the field {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i x} \cell }{component of the offset \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i y} \cell }{component of the offset \cell }
{\row }
}
}{
Definition at line {\b 228} of file {\b Field.cpp}.}\par
}
{\xe \v clearField\:Field}
{\xe \v Field\:clearField}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Field::clearField ()}}
\par
{\bkmkstart AAAAAAAADR}
{\bkmkend AAAAAAAADR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clears the entire field and cooresponding managers and graphs \par
}{
Definition at line {\b 138} of file {\b Field.cpp}.}\par
}
{\xe \v discretizeGraph\:Field}
{\xe \v Field\:discretizeGraph}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Field::discretizeGraph ()}}
\par
{\bkmkstart AAAAAAAADS}
{\bkmkend AAAAAAAADS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
add nodes to the graph that are valid places the bot can be at \par
}{
Definition at line {\b 32} of file {\b Field.cpp}.}\par
}
{\xe \v getBotPose\:Field}
{\xe \v Field\:getBotPose}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Pillar} Field::getBotPose ()}}
\par
{\bkmkstart AAAAAAAADT}
{\bkmkend AAAAAAAADT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
the robot pose on the field as a pillar. The radius is the radius of the bot \par
}}}{
Definition at line {\b 155} of file {\b Field.cpp}.}\par
}
{\xe \v getCopyPillars\:Field}
{\xe \v Field\:getCopyPillars}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< {\b Pillar} > Field::getCopyPillars ()}}
\par
{\bkmkstart AAAAAAAADU}
{\bkmkend AAAAAAAADU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
a copy of the pillars on the field \par
}}}{
Definition at line {\b 191} of file {\b Field.cpp}.}\par
}
{\xe \v getDesiredDestination\:Field}
{\xe \v Field\:getDesiredDestination}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Pose2D} Field::getDesiredDestination ()}}
\par
{\bkmkstart AAAAAAAADV}
{\bkmkend AAAAAAAADV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
get the desired destination to travel to \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
the position to get to \par
}}}{
Definition at line {\b 274} of file {\b Field.cpp}.}\par
}
{\xe \v getDesiredIndex\:Field}
{\xe \v Field\:getDesiredIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int32_t Field::getDesiredIndex () const}}
\par
{\bkmkstart AAAAAAAADW}
{\bkmkend AAAAAAAADW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
the index of the desired pillar in the graph \par
}}}{
Definition at line {\b 257} of file {\b Field.cpp}.}\par
}
{\xe \v getGraph\:Field}
{\xe \v Field\:getGraph}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Graph}< {\b Pose2D} > & Field::getGraph ()}}
\par
{\bkmkstart AAAAAAAADX}
{\bkmkend AAAAAAAADX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets a reference to the graph object on the field \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
a reference to the graph object \par
}}}{
Definition at line {\b 261} of file {\b Field.cpp}.}\par
}
{\xe \v getManager\:Field}
{\xe \v Field\:getManager}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b HoleManager} & Field::getManager ()}}
\par
{\bkmkstart AAAAAAAADY}
{\bkmkend AAAAAAAADY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets a reference to the hole manager \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
a reference to the hole manager \par
}}}{
Definition at line {\b 134} of file {\b Field.cpp}.}\par
}
{\xe \v getPillars\:Field}
{\xe \v Field\:getPillars}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::unique_ptr< std::vector< {\b Pillar} > > Field::getPillars ()}}
\par
{\bkmkstart AAAAAAAADZ}
{\bkmkend AAAAAAAADZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a unique pointer for the pillars on the field \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
the pillars on the field \par
}}}{
Definition at line {\b 142} of file {\b Field.cpp}.}\par
}
{\xe \v lineIntersectsCircle\:Field}
{\xe \v Field\:lineIntersectsCircle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Field::lineIntersectsCircle (double  {\i cx}, double  {\i cy}, double  {\i r}, double  {\i x1}, double  {\i y1}, double  {\i x2}, double  {\i y2}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAEA}
{\bkmkend AAAAAAAAEA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Util function that returns whether a given line intersects a circle \par
}{
Definition at line {\b 236} of file {\b Field.cpp}.}\par
}
{\xe \v lineIntersectsCircle\:Field}
{\xe \v Field\:lineIntersectsCircle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static bool Field::lineIntersectsCircle ({\b Pillar}  {\i p1}, const {\b Pose2D} &  {\i one}, const {\b Pose2D} &  {\i two}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAEB}
{\bkmkend AAAAAAAAEB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Util function that returns whether a given line intersects a circle \par
}{
Definition at line {\b 182} of file {\b Field.hpp}.}\par
}
{\xe \v makePath\:Field}
{\xe \v Field\:makePath}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< {\b Pose2D} > Field::makePath ()}}
\par
{\bkmkstart AAAAAAAAEC}
{\bkmkend AAAAAAAAEC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Generates a path from the graph using Dijkstra's algorithm \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
a path to the desired destination \par
}}}{
Definition at line {\b 109} of file {\b Field.cpp}.}\par
}
{\xe \v outOfBounds\:Field}
{\xe \v Field\:outOfBounds}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Field::outOfBounds (const {\b Pose2D} &  {\i location}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAED}
{\bkmkend AAAAAAAAED}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A static check to determine if a given location in the field coordinate system is out of bounds {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i location} \cell }{the position to check \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
whether that postiion is out of bounds on the field. \par
}}}{
Definition at line {\b 199} of file {\b Field.cpp}.}\par
}
{\xe \v roundRadius\:Field}
{\xe \v Field\:roundRadius}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static double Field::roundRadius (double  {\i radius}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAEE}
{\bkmkend AAAAAAAAEE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
round a given radius to possible radii {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i radius} \cell }{the radius to round \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
the rounded radius \par
}}}{
Definition at line {\b 258} of file {\b Field.hpp}.}\par
}
{\xe \v setDesiredIndex\:Field}
{\xe \v Field\:setDesiredIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Field::setDesiredIndex (int32_t  {\i index})}}
\par
{\bkmkstart AAAAAAAAEF}
{\bkmkend AAAAAAAAEF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
set the index of the desired position to travel to IN THE GRAPH {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i index} \cell }{the index IN the graph \cell }
{\row }
}
}{
Definition at line {\b 146} of file {\b Field.cpp}.}\par
}
{\xe \v setPillars\:Field}
{\xe \v Field\:setPillars}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Field::setPillars (std::unique_ptr< std::vector< {\b Pillar} > >  {\i pillars})}}
\par
{\bkmkstart AAAAAAAAEG}
{\bkmkend AAAAAAAAEG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
sets the pillars on the field {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pillars} \cell }{the pillars that the field stores \cell }
{\row }
}
}{
Definition at line {\b 151} of file {\b Field.cpp}.}\par
}
{\xe \v updateBotPose\:Field}
{\xe \v Field\:updateBotPose}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Field::updateBotPose (const {\b Pose2D} &  {\i updatedPosition})}}
\par
{\bkmkstart AAAAAAAAEH}
{\bkmkend AAAAAAAAEH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i updatedPosition} \cell }{\cell }
{\row }
}
}{
Definition at line {\b 179} of file {\b Field.cpp}.}\par
}
{\xe \v updateDesired\:Field}
{\xe \v Field\:updateDesired}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Field::updateDesired (const {\b Pose2D} &  {\i other})}}
\par
{\bkmkstart AAAAAAAAEI}
{\bkmkend AAAAAAAAEI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i other} \cell }{the new desired position \cell }
{\row }
}
}{
Definition at line {\b 265} of file {\b Field.cpp}.}\par
}
{\xe \v validLocationForNode\:Field}
{\xe \v Field\:validLocationForNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Field::validLocationForNode (const {\b Pose2D} &  {\i location})}}
\par
{\bkmkstart AAAAAAAAEJ}
{\bkmkend AAAAAAAAEJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check whether a given position is a valid place for a node in the graph with respect to "this" field {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i location} \cell }{the location of the node \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
whether it collides with anything \par
}}}{
Definition at line {\b 118} of file {\b Field.cpp}.}\par
}
{\xe \v weightGraph\:Field}
{\xe \v Field\:weightGraph}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Field::weightGraph ()}}
\par
{\bkmkstart AAAAAAAAEK}
{\bkmkend AAAAAAAAEK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Weight the graph in a way that the bot does not intersect and objects on the field \par
}{
Definition at line {\b 75} of file {\b Field.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v botPose\:Field}
{\xe \v Field\:botPose}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Pillar} Field::botPose{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAEL}
{\bkmkend AAAAAAAAEL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
THe position of the robot on the field \par
}{
Definition at line {\b 67} of file {\b Field.hpp}.}\par
}
{\xe \v desiredDestination\:Field}
{\xe \v Field\:desiredDestination}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Pose2D} Field::desiredDestination{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAEM}
{\bkmkend AAAAAAAAEM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the desired destination for the robot to get to \par
}{
Definition at line {\b 62} of file {\b Field.hpp}.}\par
}
{\xe \v desiredIndex\:Field}
{\xe \v Field\:desiredIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int32_t Field::desiredIndex = -1{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAEN}
{\bkmkend AAAAAAAAEN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The index of the desired position in the graph \par
}{
Definition at line {\b 87} of file {\b Field.hpp}.}\par
}
{\xe \v graph\:Field}
{\xe \v Field\:graph}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Graph}<{\b Pose2D}> Field::graph{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAEO}
{\bkmkend AAAAAAAAEO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The graph object which is used to generate trajectorys from nodes. Nodes represent places we can be on the field. The connections between nodes represents the possible paths we can take. The values of the connections represent the cost of moving between those nodes which is measured as the distance between nodes. \par
}{
Definition at line {\b 82} of file {\b Field.hpp}.}\par
}
{\xe \v holeManager\:Field}
{\xe \v Field\:holeManager}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b HoleManager} Field::holeManager{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAEP}
{\bkmkend AAAAAAAAEP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A hole maanger to manage and check collision with holes \par
}{
Definition at line {\b 51} of file {\b Field.hpp}.}\par
}
{\xe \v newPillars\:Field}
{\xe \v Field\:newPillars}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector<{\b Pillar}> Field::newPillars{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAEQ}
{\bkmkend AAAAAAAAEQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A queue for new pillars that we add to the field. This is used to speed up discretization and weighting of the graph. \par
}{
Definition at line {\b 93} of file {\b Field.hpp}.}\par
}
{\xe \v offset\:Field}
{\xe \v Field\:offset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Pose2D} Field::offset{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAER}
{\bkmkend AAAAAAAAER}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The amount to offset everything by after reading edges. X value stores the X (N, S) offset, Y value stores the Y (E, W) offset \par
}{
Definition at line {\b 57} of file {\b Field.hpp}.}\par
}
{\xe \v pillars\:Field}
{\xe \v Field\:pillars}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::unique_ptr<std::vector<{\b Pillar}> > Field::pillars{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAES}
{\bkmkend AAAAAAAAES}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the pillars on the field. The physical 3D cylinders get stored here \par
}{
Definition at line {\b 46} of file {\b Field.hpp}.}\par
}
{\xe \v runningError\:Field}
{\xe \v Field\:runningError}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Pose2D} Field::runningError{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAET}
{\bkmkend AAAAAAAAET}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the running error that we have accumulated over time in our measurements. This is just an approixmation based on read in error from the IPC \par
}{
Definition at line {\b 73} of file {\b Field.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/home/calebk/Documents/coding/RoombaController/src/{\b Field.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/home/calebk/Documents/coding/RoombaController/src/{\b Field.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Graph< V > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v Graph< V >}
{\xe \v Graph< V >}
{\bkmkstart AAAAAAAAEU}
{\bkmkend AAAAAAAAEU}
\par
{
{\f2 #include <Graph.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b CustomCompare}}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b addNode} ({\b Node}< {\b V} > *{\b newNode})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b addNode} ({\b Node}< {\b V} > *{\b nextNode}, std::vector< {\b Node}< {\b V} > * > {\b adjacentNodes}, {\b double} {\b weight})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b addNode} ({\b Node}< {\b V} > *{\b nextNode}, std::vector< {\b Node}< {\b V} > * > {\b adjacentNodes})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b addNode} ({\b Node}< {\b V} > *{\b nextNode}, {\b Node}< {\b V} > *{\b nodeITSLATE})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b addConnection} ({\b Node}< {\b V} > *{\b one}, {\b Node}< {\b V} > *{\b two}, {\b double} {\b weight})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b addConnection} ({\b Node}< {\b V} > *{\b one}, {\b Node}< {\b V} > *{\b two})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b addNode} ({\b Node}< {\b V} > *{\b nextNode}, {\b Node}< {\b V} > *{\b nodeITSLATE}, {\b double} {\b weight})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b setHead} ({\b int} {\b index})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b removeNode} ({\b size_t} {\b index})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b Node}< {\b V} > * > {\b Dijkstra} ({\b Node}< {\b V} > *{\b from}, {\b Node}< {\b V} > *{\b find})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< std::vector< {\b double} > > {\b getAdjacencyList} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b Node}< {\b V} > * > {\b getAdj} ({\b Node}< {\b V} > *{\b next})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b Node}< {\b V} > * > {\b getNodes} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Graph} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~Graph} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b typedef} std::pair< {\b double}, std::vector< {\b Node}< {\b V} > * > > {\b pair}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b void} {\b resize} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b int} {\b numVisited} (std::vector< {\b bool} > {\b listOfBools})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b contains} ({\b Node}< {\b V} > *{\b node}, std::vector< {\b Node}< {\b V} > * > {\b listOfNodes})\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b Node}< {\b V} > * > {\b nodes}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< std::vector< {\b double} > > {\b matrix}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Node}< {\b V} > * {\b head} = {\b nullptr}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::map< {\b Node}< {\b V} > *, {\b unsigned} {\b int} > {\b nodeMap}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<{\b typename} {\b V}>\par
class Graph< V >\par
}
\par
{
Definition at line {\b 17} of file {\b Graph.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v pair\:Graph< V >}
{\xe \v Graph< V >\:pair}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b typename} {\b V} > {\b typedef} std::pair<{\b double}, std::vector<{\b Node}<{\b V}>*> > {\b Graph}< {\b V} >::pair{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAEV}
{\bkmkend AAAAAAAAEV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 19} of file {\b Graph.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Graph\:Graph< V >}
{\xe \v Graph< V >\:Graph}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b typename} {\b V} > {\b Graph}< {\b V} >{\b ::Graph} ()}}
\par
{\bkmkstart AAAAAAAAEW}
{\bkmkend AAAAAAAAEW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 14} of file {\b Graph.cpp}.}\par
}
{\xe \v ~Graph\:Graph< V >}
{\xe \v Graph< V >\:~Graph}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b typename} {\b V} > {\b Graph}< {\b V} >::~{\b Graph} ()}}
\par
{\bkmkstart AAAAAAAAEX}
{\bkmkend AAAAAAAAEX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 254} of file {\b Graph.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addConnection\:Graph< V >}
{\xe \v Graph< V >\:addConnection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b typename} {\b V} > {\b void} {\b Graph}< {\b V} >::addConnection ({\b Node}< {\b V} > *  {\i one}, {\b Node}< {\b V} > *  {\i two})}}
\par
{\bkmkstart AAAAAAAAEY}
{\bkmkend AAAAAAAAEY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a connection between two nodes {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i one} \cell }{node one \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i two} \cell }{node two \cell }
{\row }
}
}{
Definition at line {\b 277} of file {\b Graph.cpp}.}\par
}
{\xe \v addConnection\:Graph< V >}
{\xe \v Graph< V >\:addConnection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b typename} {\b V} > {\b void} {\b Graph}< {\b V} >::addConnection ({\b Node}< {\b V} > *  {\i one}, {\b Node}< {\b V} > *  {\i two}, {\b double}  {\i weight})}}
\par
{\bkmkstart AAAAAAAAEZ}
{\bkmkend AAAAAAAAEZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
add a weight between nodes {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i one} \cell }{the first node \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i two} \cell }{the second node \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i weight} \cell }{the weight to put between them \cell }
{\row }
}
}{
Definition at line {\b 267} of file {\b Graph.cpp}.}\par
}
{\xe \v addNode\:Graph< V >}
{\xe \v Graph< V >\:addNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b typename} {\b V} > {\b void} {\b Graph}< {\b V} >::addNode ({\b Node}< {\b V} > *  {\i newNode})}}
\par
{\bkmkstart AAAAAAAAFA}
{\bkmkend AAAAAAAAFA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a node to the graph {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i newNode} \cell }{a new node to add to the graph \cell }
{\row }
}
}{
Definition at line {\b 102} of file {\b Graph.cpp}.}\par
}
{\xe \v addNode\:Graph< V >}
{\xe \v Graph< V >\:addNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b typename} {\b V} > {\b void} {\b Graph}< {\b V} >::addNode ({\b Node}< {\b V} > *  {\i nextNode}, {\b Node}< {\b V} > *  {\i nodeITSLATE})}}
\par
{\bkmkstart AAAAAAAAFB}
{\bkmkend AAAAAAAAFB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a node with a connection {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i nextNode} \cell }{the node to add \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i nodeITSLATE} \cell }{a node to add a connection to \cell }
{\row }
}
}{
Definition at line {\b 132} of file {\b Graph.cpp}.}\par
}
{\xe \v addNode\:Graph< V >}
{\xe \v Graph< V >\:addNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b typename} {\b V} > {\b void} {\b Graph}< {\b V} >::addNode ({\b Node}< {\b V} > *  {\i nextNode}, {\b Node}< {\b V} > *  {\i nodeITSLATE}, {\b double}  {\i weight})}}
\par
{\bkmkstart AAAAAAAAFC}
{\bkmkend AAAAAAAAFC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a node with a weight to the graph {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i nextNode} \cell }{the node to add \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i nodeITSLATE} \cell }{the node to connect to \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i weight} \cell }{the weight between those vertices \cell }
{\row }
}
}{
Definition at line {\b 282} of file {\b Graph.cpp}.}\par
}
{\xe \v addNode\:Graph< V >}
{\xe \v Graph< V >\:addNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b typename} {\b V} > {\b void} {\b Graph}< {\b V} >::addNode ({\b Node}< {\b V} > *  {\i nextNode}, std::vector< {\b Node}< {\b V} > * >  {\i adjacentNodes})}}
\par
{\bkmkstart AAAAAAAAFD}
{\bkmkend AAAAAAAAFD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a node {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i nextNode} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i adjacentNodes} \cell }{\cell }
{\row }
}
}{
Definition at line {\b 127} of file {\b Graph.cpp}.}\par
}
{\xe \v addNode\:Graph< V >}
{\xe \v Graph< V >\:addNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b typename} {\b V} > {\b void} {\b Graph}< {\b V} >::addNode ({\b Node}< {\b V} > *  {\i nextNode}, std::vector< {\b Node}< {\b V} > * >  {\i adjacentNodes}, {\b double}  {\i weight})}}
\par
{\bkmkstart AAAAAAAAFE}
{\bkmkend AAAAAAAAFE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a node with adjacent nodes all with the same weight {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i nextNode} \cell }{the node to add \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i adjacentNodes} \cell }{the nodes to make a connect for \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i weight} \cell }{the weight for all the edges \cell }
{\row }
}
}{
Definition at line {\b 111} of file {\b Graph.cpp}.}\par
}
{\xe \v contains\:Graph< V >}
{\xe \v Graph< V >\:contains}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b typename} {\b V} > {\b bool} {\b Graph}< {\b V} >::contains ({\b Node}< {\b V} > *  {\i node}, std::vector< {\b Node}< {\b V} > * >  {\i listOfNodes}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAFF}
{\bkmkend AAAAAAAAFF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the graph containes a node {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i node} \cell }{the node to determine if it's inside \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i listOfNodes} \cell }{the list of nodes to check against \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
whether node is in the list of nodes \par
}}}{
Definition at line {\b 87} of file {\b Graph.cpp}.}\par
}
{\xe \v Dijkstra\:Graph< V >}
{\xe \v Graph< V >\:Dijkstra}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b typename} {\b V} > std::vector< {\b Node}< {\b V} > * > {\b Graph}< {\b V} >::Dijkstra ({\b Node}< {\b V} > *  {\i from}, {\b Node}< {\b V} > *  {\i find})}}
\par
{\bkmkstart AAAAAAAAFG}
{\bkmkend AAAAAAAAFG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dijkstra's algorithm {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i from} \cell }{the node that you start at \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i find} \cell }{the node we want to get to \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
a path for the nodes \par
}}}{
Definition at line {\b 191} of file {\b Graph.cpp}.}\par
}
{\xe \v getAdj\:Graph< V >}
{\xe \v Graph< V >\:getAdj}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b typename} {\b V} > std::vector< {\b Node}< {\b V} > * > {\b Graph}< {\b V} >::getAdj ({\b Node}< {\b V} > *  {\i next})}}
\par
{\bkmkstart AAAAAAAAFH}
{\bkmkend AAAAAAAAFH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the adjacent nodes of a node {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i next} \cell }{the node to get its' connected nodes \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
the adjacent nodes \par
}}}{
Definition at line {\b 172} of file {\b Graph.cpp}.}\par
}
{\xe \v getAdjacencyList\:Graph< V >}
{\xe \v Graph< V >\:getAdjacencyList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b typename} {\b V} > std::vector< std::vector< {\b double} > > {\b Graph}< {\b V} >::getAdjacencyList ()}}
\par
{\bkmkstart AAAAAAAAFI}
{\bkmkend AAAAAAAAFI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
get the adjaceency matrix for the graph whihc contains the weigthings \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
the matrix for the weights \par
}}}{
Definition at line {\b 262} of file {\b Graph.cpp}.}\par
}
{\xe \v getNodes\:Graph< V >}
{\xe \v Graph< V >\:getNodes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b typename} {\b V} > std::vector< {\b Node}< {\b V} > * > {\b Graph}< {\b V} >::getNodes ()}}
\par
{\bkmkstart AAAAAAAAFJ}
{\bkmkend AAAAAAAAFJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
All the nodes \par
}}}{
Definition at line {\b 97} of file {\b Graph.cpp}.}\par
}
{\xe \v numVisited\:Graph< V >}
{\xe \v Graph< V >\:numVisited}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b typename} {\b V} > {\b int} {\b Graph}< {\b V} >::numVisited (std::vector< {\b bool} >  {\i listOfBools}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAFK}
{\bkmkend AAAAAAAAFK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
get the number of nodes we have visited {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i listOfBools} \cell }{list of bools to combine \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
the number of nodes visitied \par
}}}{
Definition at line {\b 289} of file {\b Graph.cpp}.}\par
}
{\xe \v removeNode\:Graph< V >}
{\xe \v Graph< V >\:removeNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b typename} {\b V} > {\b void} {\b Graph}< {\b V} >::removeNode ({\b size_t}  {\i index})}}
\par
{\bkmkstart AAAAAAAAFL}
{\bkmkend AAAAAAAAFL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Remove a node from the graph based on index {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i index} \cell }{the index to remove \cell }
{\row }
}
}{
Definition at line {\b 390} of file {\b Graph.cpp}.}\par
}
{\xe \v resize\:Graph< V >}
{\xe \v Graph< V >\:resize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b typename} {\b V} > {\b void} {\b Graph}< {\b V} >::resize (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAFM}
{\bkmkend AAAAAAAAFM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
resize the adjacency matrix \par
}{
Definition at line {\b 79} of file {\b Graph.cpp}.}\par
}
{\xe \v setHead\:Graph< V >}
{\xe \v Graph< V >\:setHead}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b typename} {\b V} > {\b void} {\b Graph}< {\b V} >::setHead ({\b int}  {\i index})}}
\par
{\bkmkstart AAAAAAAAFN}
{\bkmkend AAAAAAAAFN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the head of the graph {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i index} \cell }{the index to become head \cell }
{\row }
}
}{
Definition at line {\b 185} of file {\b Graph.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v head\:Graph< V >}
{\xe \v Graph< V >\:head}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b typename} {\b V} > {\b Node}<{\b V}>* {\b Graph}< {\b V} >::head = {\b nullptr}{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAFO}
{\bkmkend AAAAAAAAFO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b Graph.hpp}.}\par
}
{\xe \v matrix\:Graph< V >}
{\xe \v Graph< V >\:matrix}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b typename} {\b V} > std::vector<std::vector<{\b double}> > {\b Graph}< {\b V} >::matrix{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAFP}
{\bkmkend AAAAAAAAFP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b Graph.hpp}.}\par
}
{\xe \v nodeMap\:Graph< V >}
{\xe \v Graph< V >\:nodeMap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b typename} {\b V} > std::map<{\b Node}<{\b V}>*, {\b unsigned} {\b int}> {\b Graph}< {\b V} >::nodeMap{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAFQ}
{\bkmkend AAAAAAAAFQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 28} of file {\b Graph.hpp}.}\par
}
{\xe \v nodes\:Graph< V >}
{\xe \v Graph< V >\:nodes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b typename} {\b V} > std::vector<{\b Node}<{\b V}>*> {\b Graph}< {\b V} >::nodes{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAFR}
{\bkmkend AAAAAAAAFR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b Graph.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/home/calebk/Documents/coding/RoombaController/src/{\b Graph.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/home/calebk/Documents/coding/RoombaController/src/{\b Graph.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Hole Class Reference\par \pard\plain 
{\tc\tcl2 \v Hole}
{\xe \v Hole}
{\bkmkstart AAAAAAAAFU}
{\bkmkend AAAAAAAAFU}
\par
{
{\f2 #include <Hole.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Hole} (double X1, double Y1, double X2, double Y2, double holeSize)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Hole} (const {\b Pose2D} &positionOne, const {\b Pose2D} &positionTwo, bool foundHole, const std::vector< {\b Pose2D} > &points, double holeSize)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Hole} (double x1, double y1, double x2, double y2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Hole} (const {\b Pose2D} &positionOne, const {\b Pose2D} &positionTwo, double holeSize)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b Pose2D} > {\b getSuggestedNodePlacements} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b registerPointsToHole} (const {\b Pose2D} &positionOne, const {\b Pose2D} &positionTwo)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Pose2D} {\b copyDoOperation} (const {\b Pose2D} &position) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Pose2D} {\b getOneSquareCorner} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Pose2D} {\b getSecondSquareCorner} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b pointCouldBeMemberOfHole} (const {\b Pose2D} &measurment)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isFoundHole} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b Hole} > {\b getSubHolesCopy} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Hole} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Hole} (const {\b Hole} &hole)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Hole} (const {\b Pose2D} &initialPoint, double holeSize)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addPoint} (const {\b Pose2D} &position)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isInSquare} ({\b Pose2D} &position) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b offset} (const {\b Pose2D} &offset)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b lineIntersectsHole} (const {\b Pose2D} &posOne, const {\b Pose2D} &posTwo) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &os, const {\b Hole} &hole)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A {\b Hole} is either a complete square where we know the critical points (two vertices of the square). A {\b Hole} could also represent a bunch of points that are all within Square Length * Root(2) of eachother \par
}{
Definition at line {\b 20} of file {\b Hole.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Hole\:Hole}
{\xe \v Hole\:Hole}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Hole::Hole (double  {\i X1}, double  {\i Y1}, double  {\i X2}, double  {\i Y2}, double  {\i holeSize})}}
\par
{\bkmkstart AAAAAAAAFV}
{\bkmkend AAAAAAAAFV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Make a new hole with the given coordinates {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i X1} \cell }{one corner's X position \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i Y1} \cell }{one corner's Y position \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i X2} \cell }{the other corner's X position \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i Y2} \cell }{the other corner's Y position \cell }
{\row }
}
}{
Definition at line {\b 110} of file {\b Hole.cpp}.}\par
}
{\xe \v Hole\:Hole}
{\xe \v Hole\:Hole}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Hole::Hole (const {\b Pose2D} &  {\i positionOne}, const {\b Pose2D} &  {\i positionTwo}, bool  {\i foundHole}, const std::vector< {\b Pose2D} > &  {\i points}, double  {\i holeSize})}}
\par
{\bkmkstart AAAAAAAAFW}
{\bkmkend AAAAAAAAFW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copy constructor for hole \par
}{
Definition at line {\b 19} of file {\b Hole.cpp}.}\par
}
{\xe \v Hole\:Hole}
{\xe \v Hole\:Hole}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Hole::Hole (double  {\i x1}, double  {\i y1}, double  {\i x2}, double  {\i y2})}}
\par
{\bkmkstart AAAAAAAAFX}
{\bkmkend AAAAAAAAFX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Makes a new hole object with the given coordinates {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i x1} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i y1} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i x2} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i y2} \cell }{\cell }
{\row }
}
}{
Definition at line {\b 449} of file {\b Hole.cpp}.}\par
}
{\xe \v Hole\:Hole}
{\xe \v Hole\:Hole}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Hole::Hole (const {\b Pose2D} &  {\i positionOne}, const {\b Pose2D} &  {\i positionTwo}, double  {\i holeSize})}}
\par
{\bkmkstart AAAAAAAAFY}
{\bkmkend AAAAAAAAFY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a new {\b Hole} object\par
Created by Caleb Kugel on 11/15/2024 \par
}{
Definition at line {\b 9} of file {\b Hole.cpp}.}\par
}
{\xe \v Hole\:Hole}
{\xe \v Hole\:Hole}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Hole::Hole ()}}
\par
{\bkmkstart AAAAAAAAFZ}
{\bkmkend AAAAAAAAFZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The deafult constructor for a hole. \par
}{
Definition at line {\b 121} of file {\b Hole.cpp}.}\par
}
{\xe \v Hole\:Hole}
{\xe \v Hole\:Hole}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Hole::Hole (const {\b Hole} &  {\i hole})}}
\par
{\bkmkstart AAAAAAAAGA}
{\bkmkend AAAAAAAAGA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copy constructor \par
}{
Definition at line {\b 147} of file {\b Hole.cpp}.}\par
}
{\xe \v Hole\:Hole}
{\xe \v Hole\:Hole}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Hole::Hole (const {\b Pose2D} &  {\i initialPoint}, double  {\i holeSize}){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAAAGB}
{\bkmkend AAAAAAAAGB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Makes a new hole and stores the initial measurment {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i initialPoint} \cell }{our initial measurment \cell }
{\row }
}
}{
Definition at line {\b 129} of file {\b Hole.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addPoint\:Hole}
{\xe \v Hole\:addPoint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Hole::addPoint (const {\b Pose2D} &  {\i position})}}
\par
{\bkmkstart AAAAAAAAGC}
{\bkmkend AAAAAAAAGC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a point to this hole/chunk. Morphs this object into a found hole if possible {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i position} \cell }{the position of the measurment \cell }
{\row }
}
}{
Definition at line {\b 170} of file {\b Hole.cpp}.}\par
}
{\xe \v copyDoOperation\:Hole}
{\xe \v Hole\:copyDoOperation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Pose2D} Hole::copyDoOperation (const {\b Pose2D} &  {\i position}) const}}
\par
{\bkmkstart AAAAAAAAGD}
{\bkmkend AAAAAAAAGD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
do the whole operation and copy it into a new object for object collision {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i position} \cell }{the {\b Pose2D} to apply the big formula \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
the result of the operations \par
}}}{
Definition at line {\b 43} of file {\b Hole.cpp}.}\par
}
{\xe \v getOneSquareCorner\:Hole}
{\xe \v Hole\:getOneSquareCorner}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Pose2D} Hole::getOneSquareCorner ()}}
\par
{\bkmkstart AAAAAAAAGE}
{\bkmkend AAAAAAAAGE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
one of the square's corners \par
}}}{
Definition at line {\b 35} of file {\b Hole.cpp}.}\par
}
{\xe \v getSecondSquareCorner\:Hole}
{\xe \v Hole\:getSecondSquareCorner}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Pose2D} Hole::getSecondSquareCorner ()}}
\par
{\bkmkstart AAAAAAAAGF}
{\bkmkend AAAAAAAAGF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
the second of the square's corners \par
}}}{
Definition at line {\b 39} of file {\b Hole.cpp}.}\par
}
{\xe \v getSubHolesCopy\:Hole}
{\xe \v Hole\:getSubHolesCopy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< {\b Hole} > Hole::getSubHolesCopy () const}}
\par
{\bkmkstart AAAAAAAAGG}
{\bkmkend AAAAAAAAGG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
get a copy of the holes within holes (measurments) \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
a vector of the holes within holes \par
}}}{
Definition at line {\b 458} of file {\b Hole.cpp}.}\par
}
{\xe \v getSuggestedNodePlacements\:Hole}
{\xe \v Hole\:getSuggestedNodePlacements}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< {\b Pose2D} > Hole::getSuggestedNodePlacements ()}}
\par
{\bkmkstart AAAAAAAAGH}
{\bkmkend AAAAAAAAGH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets a list of suggested node placements, for nodes in the graph. These node placements are guranteed to not conflict with a hole, or it's measurements. \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
a list of suggested node placements \par
}}}{
Definition at line {\b 56} of file {\b Hole.cpp}.}\par
}
{\xe \v isFoundHole\:Hole}
{\xe \v Hole\:isFoundHole}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Hole::isFoundHole () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGI}
{\bkmkend AAAAAAAAGI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
whether we have found a hole \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
whether we found a hole \par
}}}{
Definition at line {\b 115} of file {\b Hole.hpp}.}\par
}
{\xe \v isInSquare\:Hole}
{\xe \v Hole\:isInSquare}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Hole::isInSquare ({\b Pose2D} &  {\i position}) const}}
\par
{\bkmkstart AAAAAAAAGJ}
{\bkmkend AAAAAAAAGJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether the passed in position is in the square {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i position} \cell }{the position to check \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
whether that position is in the square \par
}}}{
Definition at line {\b 83} of file {\b Hole.cpp}.}\par
}
{\xe \v lineIntersectsHole\:Hole}
{\xe \v Hole\:lineIntersectsHole}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Hole::lineIntersectsHole (const {\b Pose2D} &  {\i posOne}, const {\b Pose2D} &  {\i posTwo}) const}}
\par
{\bkmkstart AAAAAAAAGK}
{\bkmkend AAAAAAAAGK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Line intersects any hole measurement {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i posOne} \cell }{position one of the line \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i posTwo} \cell }{position two of the line \cell }
{\row }
}
}{
Definition at line {\b 393} of file {\b Hole.cpp}.}\par
}
{\xe \v offset\:Hole}
{\xe \v Hole\:offset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Hole::offset (const {\b Pose2D} &  {\i offset})}}
\par
{\bkmkstart AAAAAAAAGL}
{\bkmkend AAAAAAAAGL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Offset all the corners and measurements {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i offset} \cell }{the amount to offset by \cell }
{\row }
}
}{
Definition at line {\b 381} of file {\b Hole.cpp}.}\par
}
{\xe \v pointCouldBeMemberOfHole\:Hole}
{\xe \v Hole\:pointCouldBeMemberOfHole}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Hole::pointCouldBeMemberOfHole (const {\b Pose2D} &  {\i measurment})}}
\par
{\bkmkstart AAAAAAAAGM}
{\bkmkend AAAAAAAAGM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
returns whether a new point could be within the range of this hole. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i measurment} \cell }{the position of the point that may or may not be close to this hole \cell }
{\row }
}
}{
Definition at line {\b 138} of file {\b Hole.cpp}.}\par
}
{\xe \v registerPointsToHole\:Hole}
{\xe \v Hole\:registerPointsToHole}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Hole::registerPointsToHole (const {\b Pose2D} &  {\i positionOne}, const {\b Pose2D} &  {\i positionTwo})}}
\par
{\bkmkstart AAAAAAAAGN}
{\bkmkend AAAAAAAAGN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Register the corners of a hole {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i positionOne} \cell }{corner One \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i positionTwo} \cell }{Corner Two \cell }
{\row }
}
}{
Definition at line {\b 306} of file {\b Hole.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Symbol Documentation\par
\pard\plain 
{\xe \v operator<<\:Hole}
{\xe \v Hole\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & operator<< (std::ostream &  {\i os}, const {\b Hole} &  {\i hole}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAGO}
{\bkmkend AAAAAAAAGO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Override output stream for printing {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i os} \cell }{output stream \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i hole} \cell }{the hole to print \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
the hole printed in the out stream \par
}}}{
Definition at line {\b 373} of file {\b Hole.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/home/calebk/Documents/coding/RoombaController/src/{\b Hole.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/home/calebk/Documents/coding/RoombaController/src/{\b Hole.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
HoleManager Class Reference\par \pard\plain 
{\tc\tcl2 \v HoleManager}
{\xe \v HoleManager}
{\bkmkstart AAAAAAAAGP}
{\bkmkend AAAAAAAAGP}
\par
{
{\f2 #include <HoleManager.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b HoleManager} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addPoint} (const {\b Pose2D} &position)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Hole} {\b getHole} (uint8_t index)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addHole} (const {\b Hole} &hole)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addHole} (const {\b Pose2D} &cornerOne, const {\b Pose2D} &cornerTwo)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b Hole} > {\b getHoles} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b Pose2D} > {\b getPointsOnHoles} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b Pose2D} > {\b getSuggestedNodePlacements} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b nodeCollides} ({\b Pose2D} position)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b lineIntersectsAnyHoleMeasurement} (const {\b Pose2D} &positionOne, const {\b Pose2D} &positionTwo)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b offsetAll} (const {\b Pose2D} &offset) const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A hole manager handles holes that and the measurments that are associated with them. Wrapped class for lists of holes \par
}{
Definition at line {\b 18} of file {\b HoleManager.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v HoleManager\:HoleManager}
{\xe \v HoleManager\:HoleManager}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
HoleManager::HoleManager ()}}
\par
{\bkmkstart AAAAAAAAGQ}
{\bkmkend AAAAAAAAGQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creats a new {\b Hole} manager\par
Created by Caleb Kugel 11/15/2024 \par
}{
Definition at line {\b 9} of file {\b HoleManager.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addHole\:HoleManager}
{\xe \v HoleManager\:addHole}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void HoleManager::addHole (const {\b Hole} &  {\i hole})}}
\par
{\bkmkstart AAAAAAAAGR}
{\bkmkend AAAAAAAAGR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a hole to the holes {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i hole} \cell }{to add \cell }
{\row }
}
}{
Definition at line {\b 19} of file {\b HoleManager.cpp}.}\par
}
{\xe \v addHole\:HoleManager}
{\xe \v HoleManager\:addHole}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void HoleManager::addHole (const {\b Pose2D} &  {\i cornerOne}, const {\b Pose2D} &  {\i cornerTwo})}}
\par
{\bkmkstart AAAAAAAAGS}
{\bkmkend AAAAAAAAGS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a hole to the hole manager {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i cornerOne} \cell }{the first Corner \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i cornerTwo} \cell }{the second Corner \cell }
{\row }
}
}{
Definition at line {\b 14} of file {\b HoleManager.cpp}.}\par
}
{\xe \v addPoint\:HoleManager}
{\xe \v HoleManager\:addPoint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void HoleManager::addPoint (const {\b Pose2D} &  {\i position})}}
\par
{\bkmkstart AAAAAAAAGT}
{\bkmkend AAAAAAAAGT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a point that we collided on the hole with {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i position} \cell }{the position of the collision \cell }
{\row }
}
}{
Definition at line {\b 40} of file {\b HoleManager.cpp}.}\par
}
{\xe \v getHole\:HoleManager}
{\xe \v HoleManager\:getHole}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Hole} HoleManager::getHole (uint8_t  {\i index})}}
\par
{\bkmkstart AAAAAAAAGU}
{\bkmkend AAAAAAAAGU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
get a hole from registered holes {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i index} \cell }{of the hole in the holes list \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
the hole that has been registered \par
}}}{
Definition at line {\b 23} of file {\b HoleManager.cpp}.}\par
}
{\xe \v getHoles\:HoleManager}
{\xe \v HoleManager\:getHoles}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< {\b Hole} > HoleManager::getHoles ()}}
\par
{\bkmkstart AAAAAAAAGV}
{\bkmkend AAAAAAAAGV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
get the holes that we for sure know about \par
}{
Definition at line {\b 32} of file {\b HoleManager.cpp}.}\par
}
{\xe \v getPointsOnHoles\:HoleManager}
{\xe \v HoleManager\:getPointsOnHoles}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< {\b Pose2D} > HoleManager::getPointsOnHoles ()}}
\par
{\bkmkstart AAAAAAAAGW}
{\bkmkend AAAAAAAAGW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
get the points along unconfirmed holes \par
}}
{\xe \v getSuggestedNodePlacements\:HoleManager}
{\xe \v HoleManager\:getSuggestedNodePlacements}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< {\b Pose2D} > HoleManager::getSuggestedNodePlacements ()}}
\par
{\bkmkstart AAAAAAAAGX}
{\bkmkend AAAAAAAAGX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
returns a list of likely accessible nodes \par
}{
Definition at line {\b 80} of file {\b HoleManager.cpp}.}\par
}
{\xe \v lineIntersectsAnyHoleMeasurement\:HoleManager}
{\xe \v HoleManager\:lineIntersectsAnyHoleMeasurement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool HoleManager::lineIntersectsAnyHoleMeasurement (const {\b Pose2D} &  {\i positionOne}, const {\b Pose2D} &  {\i positionTwo})}}
\par
{\bkmkstart AAAAAAAAGY}
{\bkmkend AAAAAAAAGY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Determines whether a line is valid for all the hole measurements \par
}{
Definition at line {\b 94} of file {\b HoleManager.cpp}.}\par
}
{\xe \v nodeCollides\:HoleManager}
{\xe \v HoleManager\:nodeCollides}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool HoleManager::nodeCollides ({\b Pose2D}  {\i position})}}
\par
{\bkmkstart AAAAAAAAGZ}
{\bkmkend AAAAAAAAGZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether a node collides with the estimated hole or not {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i position} \cell }{the position of the node \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
whether that node is valid from a hole perspective \par
}}}{
Definition at line {\b 56} of file {\b HoleManager.cpp}.}\par
}
{\xe \v offsetAll\:HoleManager}
{\xe \v HoleManager\:offsetAll}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void HoleManager::offsetAll (const {\b Pose2D} &  {\i offset}) const}}
\par
{\bkmkstart AAAAAAAAHA}
{\bkmkend AAAAAAAAHA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
provides the offset to all holes and their values \par
}{
Definition at line {\b 117} of file {\b HoleManager.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/home/calebk/Documents/coding/RoombaController/src/{\b HoleManager.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/home/calebk/Documents/coding/RoombaController/src/{\b HoleManager.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Move Struct Reference\par \pard\plain 
{\tc\tcl2 \v Move}
{\xe \v Move}
{\bkmkstart AAAAAAAAHB}
{\bkmkend AAAAAAAAHB}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b quantity}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MovementType} {\b type}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 45} of file {\b main.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v quantity\:Move}
{\xe \v Move\:quantity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double Move::quantity}}
\par
{\bkmkstart AAAAAAAAHC}
{\bkmkend AAAAAAAAHC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 46} of file {\b main.cpp}.}\par
}
{\xe \v type\:Move}
{\xe \v Move\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MovementType} Move::type}}
\par
{\bkmkstart AAAAAAAAHD}
{\bkmkend AAAAAAAAHD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 47} of file {\b main.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/home/calebk/Documents/coding/RoombaController/src/{\b main.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Node< V > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v Node< V >}
{\xe \v Node< V >}
{\bkmkstart AAAAAAAAHE}
{\bkmkend AAAAAAAAHE}
\par
{
{\f2 #include <Node.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Node} (V data)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
V {\b getData} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetData} (V newData)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename V>\par
class Node< V >\par
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Represents a node in a graph. Really just a wrapped for V {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s80\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i V} \cell }{The data that the node encapsulates \cell }
{\row }
}
}{
Definition at line {\b 17} of file {\b Node.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Node\:Node< V >}
{\xe \v Node< V >\:Node}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename V > {\b Node}< V >{\b ::Node} (V  {\i data})}}
\par
{\bkmkstart AAAAAAAAHF}
{\bkmkend AAAAAAAAHF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs a node from given data {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i data} \cell }{to construct the node from \cell }
{\row }
}
}{
Definition at line {\b 9} of file {\b Node.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getData\:Node< V >}
{\xe \v Node< V >\:getData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename V > V {\b Node}< V >::getData ()}}
\par
{\bkmkstart AAAAAAAAHG}
{\bkmkend AAAAAAAAHG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
the data stored in the node \par
}}}{
Definition at line {\b 14} of file {\b Node.cpp}.}\par
}
{\xe \v SetData\:Node< V >}
{\xe \v Node< V >\:SetData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename V > void {\b Node}< V >::SetData (V  {\i newData})}}
\par
{\bkmkstart AAAAAAAAHH}
{\bkmkend AAAAAAAAHH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
sets the data we store in the node {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i newData} \cell }{new data to replace current data with \cell }
{\row }
}
}{
Definition at line {\b 19} of file {\b Node.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/home/calebk/Documents/coding/RoombaController/src/{\b Node.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/home/calebk/Documents/coding/RoombaController/src/{\b Node.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Pillar Class Reference\par \pard\plain 
{\tc\tcl2 \v Pillar}
{\xe \v Pillar}
{\bkmkstart AAAAAAAAHI}
{\bkmkend AAAAAAAAHI}
\par
{
{\f2 #include <Pillar.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Pillar} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Pillar} (const {\b Pose2D} &{\b position}, double {\b radius})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Pillar} (double x, double y, double heading, double {\b radius})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Pillar} (double x, double y, double {\b radius})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Pose2D} & {\b getPose} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b getX} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b getY} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b getRadius} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setRadius} (double newRadius)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPosition} (const {\b Pose2D} &newPosition)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b Pillar} {\b parseFromStream} (std::istringstream &stream)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Pose2D} {\b position}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b radius}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A {\b Pillar} is a cyclinder on the field. It has both a position and a radius. \par
}{
Definition at line {\b 14} of file {\b Pillar.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Pillar\:Pillar}
{\xe \v Pillar\:Pillar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Pillar::Pillar ()}}
\par
{\bkmkstart AAAAAAAAHJ}
{\bkmkend AAAAAAAAHJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs a new pillar object \par
}{
Definition at line {\b 7} of file {\b Pillar.cpp}.}\par
}
{\xe \v Pillar\:Pillar}
{\xe \v Pillar\:Pillar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Pillar::Pillar (const {\b Pose2D} &  {\i position}, double  {\i radius})}}
\par
{\bkmkstart AAAAAAAAHK}
{\bkmkend AAAAAAAAHK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Makes a new pillar with given position and radius {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i position} \cell }{the position of the pillar on the field \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i radius} \cell }{the radius of the pillar on the field \cell }
{\row }
}
}{
Definition at line {\b 18} of file {\b Pillar.cpp}.}\par
}
{\xe \v Pillar\:Pillar}
{\xe \v Pillar\:Pillar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Pillar::Pillar (double  {\i x}, double  {\i y}, double  {\i heading}, double  {\i radius})}}
\par
{\bkmkstart AAAAAAAAHL}
{\bkmkend AAAAAAAAHL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs a new pillar from components {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i x} \cell }{component of position \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i y} \cell }{component of position \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i heading} \cell }{component of position \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i radius} \cell }{of the pillar \cell }
{\row }
}
}{
Definition at line {\b 12} of file {\b Pillar.cpp}.}\par
}
{\xe \v Pillar\:Pillar}
{\xe \v Pillar\:Pillar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Pillar::Pillar (double  {\i x}, double  {\i y}, double  {\i radius})}}
\par
{\bkmkstart AAAAAAAAHM}
{\bkmkend AAAAAAAAHM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs a new pillar from components. ignores heading {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i x} \cell }{the x component of the position \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i y} \cell }{the y component of the position \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i radius} \cell }{the radius of the pillar \cell }
{\row }
}
}{
Definition at line {\b 23} of file {\b Pillar.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getPose\:Pillar}
{\xe \v Pillar\:getPose}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Pose2D} & Pillar::getPose ()}}
\par
{\bkmkstart AAAAAAAAHN}
{\bkmkend AAAAAAAAHN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets a reference to the position of the pillar. If {\b Pose2D} functions are called on that reference it will effect this pillars position \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
the position of the pillar \par
}}}{
Definition at line {\b 29} of file {\b Pillar.cpp}.}\par
}
{\xe \v getRadius\:Pillar}
{\xe \v Pillar\:getRadius}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double Pillar::getRadius () const}}
\par
{\bkmkstart AAAAAAAAHO}
{\bkmkend AAAAAAAAHO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
the radius of the pillar \par
}}}{
Definition at line {\b 41} of file {\b Pillar.cpp}.}\par
}
{\xe \v getX\:Pillar}
{\xe \v Pillar\:getX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double Pillar::getX ()}}
\par
{\bkmkstart AAAAAAAAHP}
{\bkmkend AAAAAAAAHP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The X compoenent of the position \par
}}}{
Definition at line {\b 33} of file {\b Pillar.cpp}.}\par
}
{\xe \v getY\:Pillar}
{\xe \v Pillar\:getY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double Pillar::getY ()}}
\par
{\bkmkstart AAAAAAAAHQ}
{\bkmkend AAAAAAAAHQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The y component of the positoon \par
}}}{
Definition at line {\b 37} of file {\b Pillar.cpp}.}\par
}
{\xe \v parseFromStream\:Pillar}
{\xe \v Pillar\:parseFromStream}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Pillar} Pillar::parseFromStream (std::istringstream &  {\i stream}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAHR}
{\bkmkend AAAAAAAAHR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Makes a pillar from a given string stream. Formatted as: X Y theta R {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i stream} \cell }{the stream in which to parse the pillar from \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
the pillar from the data in the stream \par
}}}{
Definition at line {\b 50} of file {\b Pillar.cpp}.}\par
}
{\xe \v setPosition\:Pillar}
{\xe \v Pillar\:setPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Pillar::setPosition (const {\b Pose2D} &  {\i newPosition})}}
\par
{\bkmkstart AAAAAAAAHS}
{\bkmkend AAAAAAAAHS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the position of the pillar {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i newPosition} \cell }{the new position to set to \cell }
{\row }
}
}{
Definition at line {\b 58} of file {\b Pillar.cpp}.}\par
}
{\xe \v setRadius\:Pillar}
{\xe \v Pillar\:setRadius}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Pillar::setRadius (double  {\i newRadius})}}
\par
{\bkmkstart AAAAAAAAHT}
{\bkmkend AAAAAAAAHT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the radius of the pillar {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i newRadius} \cell }{the radius to set to \cell }
{\row }
}
}{
Definition at line {\b 45} of file {\b Pillar.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v position\:Pillar}
{\xe \v Pillar\:position}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Pose2D} Pillar::position{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAHU}
{\bkmkend AAAAAAAAHU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pose to handle position and related math \par
}{
Definition at line {\b 19} of file {\b Pillar.hpp}.}\par
}
{\xe \v radius\:Pillar}
{\xe \v Pillar\:radius}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double Pillar::radius{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAHV}
{\bkmkend AAAAAAAAHV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The radius of the pillar \par
}{
Definition at line {\b 24} of file {\b Pillar.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/home/calebk/Documents/coding/RoombaController/src/{\b Pillar.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/home/calebk/Documents/coding/RoombaController/src/{\b Pillar.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Pose2D Class Reference\par \pard\plain 
{\tc\tcl2 \v Pose2D}
{\xe \v Pose2D}
{\bkmkstart AAAAAAAAHW}
{\bkmkend AAAAAAAAHW}
\par
{
{\f2 #include <Pose2D.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Pose2D} (double {\b x}, double {\b y}, double {\b heading})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Pose2D} (double {\b x}, double {\b y})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Pose2D} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Pose2D} (const {\b Pose2D} &position)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b angleTo} (const {\b Pose2D} &other) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b distanceTo} (const {\b Pose2D} &other) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b squareOfDistanceTo} (const {\b Pose2D} &other) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Pose2D} {\b clone} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b rotateByPose} (const {\b Pose2D} &rotation)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b rotateByAngle} (double angle)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b translateByPose} (const {\b Pose2D} &translation)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b translateByMagnitude} (double magnitude)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b transformPose} (const {\b Pose2D} &modifier)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b getX} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b getY} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b getHeading} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setHeading} (double angle)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b plusCoord} (const {\b Pose2D} &other)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b plus} (const {\b Pose2D} &other)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b minus} ({\b Pose2D} other)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addAngle} (double angle)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Pose2D} {\b subtractBy} (const {\b Pose2D} &other) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Pose2D} {\b scaleBy} (double scaler) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Pose2D} {\b normalize} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b dotProduct} (const {\b Pose2D} &other) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setX} (double {\b x})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vecAdd} (double angle, double magnitude)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setY} (double {\b y})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b getQuadrant} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b wrapHeading} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b transformForPose} (const {\b Pose2D} &other)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isOnLine} ({\b Pose2D} LineEnd1, {\b Pose2D} LineEnd2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isPerpendicularToLine} (double m)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b multiply} (double d)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b Pose2D} {\b fromPolar} (double magnitude, double angle)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static double {\b degreesToRadians} (double degrees)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static double {\b radiansToDegrees} (double radians)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b Pose2D} {\b parseFromStream} (std::istringstream &stream)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static double {\b getAngleBetweenPoints} ({\b Pose2D} corner, {\b Pose2D} end1, {\b Pose2D} end2)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b x}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b y}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b heading}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &os, const {\b Pose2D} &d)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A class representing a 2D position and a heading. Implements common vector functions \par
}{
Definition at line {\b 23} of file {\b Pose2D.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Pose2D\:Pose2D}
{\xe \v Pose2D\:Pose2D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Pose2D::Pose2D (double  {\i x}, double  {\i y}, double  {\i heading})}}
\par
{\bkmkstart AAAAAAAAHX}
{\bkmkend AAAAAAAAHX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Consctructs a new {\b Pose2D} object {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i x} \cell }{the x component \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i y} \cell }{the y component \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i heading} \cell }{the heading \cell }
{\row }
}
}{
Definition at line {\b 7} of file {\b Pose2D.cpp}.}\par
}
{\xe \v Pose2D\:Pose2D}
{\xe \v Pose2D\:Pose2D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Pose2D::Pose2D (double  {\i x}, double  {\i y})}}
\par
{\bkmkstart AAAAAAAAHY}
{\bkmkend AAAAAAAAHY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs a new {\b Pose2D} object {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i x} \cell }{component \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i y} \cell }{component \cell }
{\row }
}
}{
Definition at line {\b 13} of file {\b Pose2D.cpp}.}\par
}
{\xe \v Pose2D\:Pose2D}
{\xe \v Pose2D\:Pose2D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Pose2D::Pose2D ()}}
\par
{\bkmkstart AAAAAAAAHZ}
{\bkmkend AAAAAAAAHZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Makes a new {\b Pose2D} with 0's as default \par
}{
Definition at line {\b 18} of file {\b Pose2D.cpp}.}\par
}
{\xe \v Pose2D\:Pose2D}
{\xe \v Pose2D\:Pose2D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Pose2D::Pose2D (const {\b Pose2D} &  {\i position})}}
\par
{\bkmkstart AAAAAAAAIA}
{\bkmkend AAAAAAAAIA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs a new {\b Pose2D}. Copy constructor. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i position} \cell }{the pose to copy \cell }
{\row }
}
}{
Definition at line {\b 64} of file {\b Pose2D.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addAngle\:Pose2D}
{\xe \v Pose2D\:addAngle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Pose2D::addAngle (double  {\i angle})}}
\par
{\bkmkstart AAAAAAAAIB}
{\bkmkend AAAAAAAAIB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add the angle to heading {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i angle} \cell }{gets added to "this" heading \cell }
{\row }
}
}{
Definition at line {\b 82} of file {\b Pose2D.cpp}.}\par
}
{\xe \v angleTo\:Pose2D}
{\xe \v Pose2D\:angleTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double Pose2D::angleTo (const {\b Pose2D} &  {\i other}) const}}
\par
{\bkmkstart AAAAAAAAIC}
{\bkmkend AAAAAAAAIC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculates the angle from one node to another {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i other} \cell }{angle to get to \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
the angle between two nodes \par
}}}{
Definition at line {\b 78} of file {\b Pose2D.cpp}.}\par
}
{\xe \v clone\:Pose2D}
{\xe \v Pose2D\:clone}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Pose2D} Pose2D::clone () const}}
\par
{\bkmkstart AAAAAAAAID}
{\bkmkend AAAAAAAAID}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Makes a copy of this node \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
the copy of this node \par
}}}{
Definition at line {\b 106} of file {\b Pose2D.cpp}.}\par
}
{\xe \v degreesToRadians\:Pose2D}
{\xe \v Pose2D\:degreesToRadians}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double Pose2D::degreesToRadians (double  {\i degrees}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAIE}
{\bkmkend AAAAAAAAIE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculates the radian equivalent of degrees {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i degrees} \cell }{the angle in degrees \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
the angle in radians \par
}}}{
Definition at line {\b 200} of file {\b Pose2D.cpp}.}\par
}
{\xe \v distanceTo\:Pose2D}
{\xe \v Pose2D\:distanceTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double Pose2D::distanceTo (const {\b Pose2D} &  {\i other}) const}}
\par
{\bkmkstart AAAAAAAAIF}
{\bkmkend AAAAAAAAIF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculates the distance between two nodes {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i other} \cell }{the other node to calculate the distance to \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
the distance between the two nodes \par
}}}{
Definition at line {\b 86} of file {\b Pose2D.cpp}.}\par
}
{\xe \v dotProduct\:Pose2D}
{\xe \v Pose2D\:dotProduct}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double Pose2D::dotProduct (const {\b Pose2D} &  {\i other}) const}}
\par
{\bkmkstart AAAAAAAAIG}
{\bkmkend AAAAAAAAIG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculate the dot product from the nodes: "this" and other {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i other} \cell }{other node to calculate the dot product with \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
a double resembling the dot product \par
}}}{
Definition at line {\b 226} of file {\b Pose2D.cpp}.}\par
}
{\xe \v fromPolar\:Pose2D}
{\xe \v Pose2D\:fromPolar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Pose2D} Pose2D::fromPolar (double  {\i magnitude}, double  {\i angle}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAIH}
{\bkmkend AAAAAAAAIH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a new {\b Pose2D} from polar coordinats {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i magnitude} \cell }{the magnitude of the position \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i angle} \cell }{the angle of the position \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A {\b Pose2D} object representing the polar coordinates \par
}}}{
Definition at line {\b 193} of file {\b Pose2D.cpp}.}\par
}
{\xe \v getAngleBetweenPoints\:Pose2D}
{\xe \v Pose2D\:getAngleBetweenPoints}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static double Pose2D::getAngleBetweenPoints ({\b Pose2D}  {\i corner}, {\b Pose2D}  {\i end1}, {\b Pose2D}  {\i end2}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAII}
{\bkmkend AAAAAAAAII}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
gets the angle between points in radians. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i corner} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i end1} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i end2} \cell }{\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
the angle between all of these points \par
}}}}
{\xe \v getHeading\:Pose2D}
{\xe \v Pose2D\:getHeading}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double Pose2D::getHeading () const}}
\par
{\bkmkstart AAAAAAAAIJ}
{\bkmkend AAAAAAAAIJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
get the heading of the position \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
the heading of the bot \par
}}}{
Definition at line {\b 155} of file {\b Pose2D.cpp}.}\par
}
{\xe \v getQuadrant\:Pose2D}
{\xe \v Pose2D\:getQuadrant}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t Pose2D::getQuadrant () const}}
\par
{\bkmkstart AAAAAAAAIK}
{\bkmkend AAAAAAAAIK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the quadrant that a Pose is in. If the pose is on the origin or on an intercept it return's 0. otherwise going from pos pos (1) it travels counter clockwise around in a circle \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
(0, 0): 0 (+, +): 1 (-, +): 2 (-, -): 3 (+, -): 4 \par
}}}{
Definition at line {\b 171} of file {\b Pose2D.cpp}.}\par
}
{\xe \v getX\:Pose2D}
{\xe \v Pose2D\:getX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double Pose2D::getX () const}}
\par
{\bkmkstart AAAAAAAAIL}
{\bkmkend AAAAAAAAIL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
get the x component of the position \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
the c component \par
}}}{
Definition at line {\b 147} of file {\b Pose2D.cpp}.}\par
}
{\xe \v getY\:Pose2D}
{\xe \v Pose2D\:getY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double Pose2D::getY () const}}
\par
{\bkmkstart AAAAAAAAIM}
{\bkmkend AAAAAAAAIM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
gets the y component of the position \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
the y component \par
}}}{
Definition at line {\b 151} of file {\b Pose2D.cpp}.}\par
}
{\xe \v isOnLine\:Pose2D}
{\xe \v Pose2D\:isOnLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Pose2D::isOnLine ({\b Pose2D}  {\i LineEnd1}, {\b Pose2D}  {\i LineEnd2})}}
\par
{\bkmkstart AAAAAAAAIN}
{\bkmkend AAAAAAAAIN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Makes a slope intercept object from two pose2Ds {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i one} \cell }{the first position \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i two} \cell }{the second position \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Slope intercept object that runs through two points Determines whether a pose is on a given bounded line \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i LineEnd1} \cell }{one endpoint of the line \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i LineEnd2} \cell }{the other endpoint of the line \cell }
{\row }
}
}{
Definition at line {\b 24} of file {\b Pose2D.cpp}.}\par
}
{\xe \v isPerpendicularToLine\:Pose2D}
{\xe \v Pose2D\:isPerpendicularToLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Pose2D::isPerpendicularToLine (double  {\i m})}}
\par
{\bkmkstart AAAAAAAAIO}
{\bkmkend AAAAAAAAIO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Determines whether a position is perpendicular to a given line \par
}}
{\xe \v minus\:Pose2D}
{\xe \v Pose2D\:minus}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Pose2D::minus ({\b Pose2D}  {\i other})}}
\par
{\bkmkstart AAAAAAAAIP}
{\bkmkend AAAAAAAAIP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Subtract this by other. Subtracts the components {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i other} \cell }{the other node to subtract by \cell }
{\row }
}
}{
Definition at line {\b 187} of file {\b Pose2D.cpp}.}\par
}
{\xe \v multiply\:Pose2D}
{\xe \v Pose2D\:multiply}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Pose2D::multiply (double  {\i d})}}
\par
{\bkmkstart AAAAAAAAIQ}
{\bkmkend AAAAAAAAIQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Multiplys the x and y components by a scalar \par
}{
Definition at line {\b 267} of file {\b Pose2D.cpp}.}\par
}
{\xe \v normalize\:Pose2D}
{\xe \v Pose2D\:normalize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Pose2D} Pose2D::normalize () const}}
\par
{\bkmkstart AAAAAAAAIR}
{\bkmkend AAAAAAAAIR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Normalizes a position to a unit vector \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
a unit vector representing this position \par
}}}{
Definition at line {\b 221} of file {\b Pose2D.cpp}.}\par
}
{\xe \v parseFromStream\:Pose2D}
{\xe \v Pose2D\:parseFromStream}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Pose2D} Pose2D::parseFromStream (std::istringstream &  {\i stream}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAIS}
{\bkmkend AAAAAAAAIS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Parse a pose 2d from a string stream {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i stream} \cell }{the stream to parse from \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
a pose2D from the data in the stream \par
}}}{
Definition at line {\b 204} of file {\b Pose2D.cpp}.}\par
}
{\xe \v plus\:Pose2D}
{\xe \v Pose2D\:plus}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Pose2D::plus (const {\b Pose2D} &  {\i other})}}
\par
{\bkmkstart AAAAAAAAIT}
{\bkmkend AAAAAAAAIT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Computes a vector addition. Adds components of vectors together {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i other} \cell }{the other pose \cell }
{\row }
}
}{
Definition at line {\b 100} of file {\b Pose2D.cpp}.}\par
}
{\xe \v plusCoord\:Pose2D}
{\xe \v Pose2D\:plusCoord}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Pose2D::plusCoord (const {\b Pose2D} &  {\i other})}}
\par
{\bkmkstart AAAAAAAAIU}
{\bkmkend AAAAAAAAIU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sum of two coordinates {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i other} \cell }{the node to add \cell }
{\row }
}
}{
Definition at line {\b 123} of file {\b Pose2D.cpp}.}\par
}
{\xe \v radiansToDegrees\:Pose2D}
{\xe \v Pose2D\:radiansToDegrees}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static double Pose2D::radiansToDegrees (double  {\i radians}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAIV}
{\bkmkend AAAAAAAAIV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculates the degree equivalent of radians {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i radians} \cell }{the angle in radians \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
the angle in degrees \par
}}}}
{\xe \v rotateByAngle\:Pose2D}
{\xe \v Pose2D\:rotateByAngle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Pose2D::rotateByAngle (double  {\i angle})}}
\par
{\bkmkstart AAAAAAAAIW}
{\bkmkend AAAAAAAAIW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Uses a rotation matrix to rotate a {\b Pose2D} by an angle. Rotates about the origin. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i angle} \cell }{to rotate by. \cell }
{\row }
}
}{
Definition at line {\b 116} of file {\b Pose2D.cpp}.}\par
}
{\xe \v rotateByPose\:Pose2D}
{\xe \v Pose2D\:rotateByPose}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Pose2D::rotateByPose (const {\b Pose2D} &  {\i rotation})}}
\par
{\bkmkstart AAAAAAAAIX}
{\bkmkend AAAAAAAAIX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Rotate a {\b Pose2D} by the a rotation cooresponding to the heading of the other pose {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i rotation} \cell }{the pose to rotate by \cell }
{\row }
}
}{
Definition at line {\b 128} of file {\b Pose2D.cpp}.}\par
}
{\xe \v scaleBy\:Pose2D}
{\xe \v Pose2D\:scaleBy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Pose2D} Pose2D::scaleBy (double  {\i scaler}) const}}
\par
{\bkmkstart AAAAAAAAIY}
{\bkmkend AAAAAAAAIY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Scales a position by another. Returs result {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i scaler} \cell }{amount to scale this vector as a pose by \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
the result of the scaling operation \par
}}}{
Definition at line {\b 217} of file {\b Pose2D.cpp}.}\par
}
{\xe \v setHeading\:Pose2D}
{\xe \v Pose2D\:setHeading}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Pose2D::setHeading (double  {\i angle})}}
\par
{\bkmkstart AAAAAAAAIZ}
{\bkmkend AAAAAAAAIZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the heading of the Pose {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i angle} \cell }{the angle to set the Pose at \cell }
{\row }
}
}{
Definition at line {\b 159} of file {\b Pose2D.cpp}.}\par
}
{\xe \v setX\:Pose2D}
{\xe \v Pose2D\:setX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Pose2D::setX (double  {\i x})}}
\par
{\bkmkstart AAAAAAAAJA}
{\bkmkend AAAAAAAAJA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setter for x {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i x} \cell }{the new x value \cell }
{\row }
}
}{
Definition at line {\b 163} of file {\b Pose2D.cpp}.}\par
}
{\xe \v setY\:Pose2D}
{\xe \v Pose2D\:setY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Pose2D::setY (double  {\i y})}}
\par
{\bkmkstart AAAAAAAAJB}
{\bkmkend AAAAAAAAJB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setter for y {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i y} \cell }{the new y value \cell }
{\row }
}
}{
Definition at line {\b 167} of file {\b Pose2D.cpp}.}\par
}
{\xe \v squareOfDistanceTo\:Pose2D}
{\xe \v Pose2D\:squareOfDistanceTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double Pose2D::squareOfDistanceTo (const {\b Pose2D} &  {\i other}) const}}
\par
{\bkmkstart AAAAAAAAJC}
{\bkmkend AAAAAAAAJC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
calculate the squared distance to another object {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i other} \cell }{the object to get the squared distance to \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
the squared distance to the other object \par
}}}{
Definition at line {\b 90} of file {\b Pose2D.cpp}.}\par
}
{\xe \v subtractBy\:Pose2D}
{\xe \v Pose2D\:subtractBy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Pose2D} Pose2D::subtractBy (const {\b Pose2D} &  {\i other}) const}}
\par
{\bkmkstart AAAAAAAAJD}
{\bkmkend AAAAAAAAJD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Subtract "this" from other by components and return the result {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i other} \cell }{the other node to subtract by \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
the result of the subtraction \par
}}}{
Definition at line {\b 213} of file {\b Pose2D.cpp}.}\par
}
{\xe \v transformForPose\:Pose2D}
{\xe \v Pose2D\:transformForPose}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Pose2D::transformForPose (const {\b Pose2D} &  {\i other})}}
\par
{\bkmkstart AAAAAAAAJE}
{\bkmkend AAAAAAAAJE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
transforms a given pose for another's frame {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i other} \cell }{the other frame \cell }
{\row }
}
}{
Definition at line {\b 94} of file {\b Pose2D.cpp}.}\par
}
{\xe \v transformPose\:Pose2D}
{\xe \v Pose2D\:transformPose}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Pose2D::transformPose (const {\b Pose2D} &  {\i modifier})}}
\par
{\bkmkstart AAAAAAAAJF}
{\bkmkend AAAAAAAAJF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
transform a position with a rotation and a translation {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i modifier} \cell }{the heading gets used as the rotation. The compoenent get used as the translation \cell }
{\row }
}
}{
Definition at line {\b 142} of file {\b Pose2D.cpp}.}\par
}
{\xe \v translateByMagnitude\:Pose2D}
{\xe \v Pose2D\:translateByMagnitude}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Pose2D::translateByMagnitude (double  {\i magnitude})}}
\par
{\bkmkstart AAAAAAAAJG}
{\bkmkend AAAAAAAAJG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is admitedly a bit of a goofy function. We take the magnitude of the translation and extend the current position by that much in the heading of the pose. I like to think of the {\b Pose2D} as a vector, then we take the heading and combine it into a pollar coordinate with the magnitude. Then we do vector addition on the {\b Pose2D}. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i magnitude} \cell }{to extend by \cell }
{\row }
}
}{
Definition at line {\b 137} of file {\b Pose2D.cpp}.}\par
}
{\xe \v translateByPose\:Pose2D}
{\xe \v Pose2D\:translateByPose}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Pose2D::translateByPose (const {\b Pose2D} &  {\i translation})}}
\par
{\bkmkstart AAAAAAAAJH}
{\bkmkend AAAAAAAAJH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Translation for a pose by another pose. Vector addition {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i translation} \cell }{the pose to add \cell }
{\row }
}
}{
Definition at line {\b 132} of file {\b Pose2D.cpp}.}\par
}
{\xe \v vecAdd\:Pose2D}
{\xe \v Pose2D\:vecAdd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Pose2D::vecAdd (double  {\i angle}, double  {\i magnitude})}}
\par
{\bkmkstart AAAAAAAAJI}
{\bkmkend AAAAAAAAJI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Computes a vector addition from an angle and quantity {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i angle} \cell }{the angle component of the vector \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i magnitude} \cell }{the quantity component of the vector \cell }
{\row }
}
}{
Definition at line {\b 110} of file {\b Pose2D.cpp}.}\par
}
{\xe \v wrapHeading\:Pose2D}
{\xe \v Pose2D\:wrapHeading}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Pose2D::wrapHeading ()}}
\par
{\bkmkstart AAAAAAAAJJ}
{\bkmkend AAAAAAAAJJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Wraps a heading to - PI -> PI \par
}{
Definition at line {\b 235} of file {\b Pose2D.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Symbol Documentation\par
\pard\plain 
{\xe \v operator<<\:Pose2D}
{\xe \v Pose2D\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & operator<< (std::ostream &  {\i os}, const {\b Pose2D} &  {\i d}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAJK}
{\bkmkend AAAAAAAAJK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To string for a pose2D {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i os} \cell }{output stream \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i d} \cell }{the pose2D to reference \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
\par
}}}{
Definition at line {\b 230} of file {\b Pose2D.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v heading\:Pose2D}
{\xe \v Pose2D\:heading}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double Pose2D::heading{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAJL}
{\bkmkend AAAAAAAAJL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b Pose2D.hpp}.}\par
}
{\xe \v x\:Pose2D}
{\xe \v Pose2D\:x}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double Pose2D::x{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAJM}
{\bkmkend AAAAAAAAJM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b Pose2D.hpp}.}\par
}
{\xe \v y\:Pose2D}
{\xe \v Pose2D\:y}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double Pose2D::y{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAJN}
{\bkmkend AAAAAAAAJN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b Pose2D.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/home/calebk/Documents/coding/RoombaController/src/{\b Pose2D.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/home/calebk/Documents/coding/RoombaController/src/{\b Pose2D.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Rectangle Struct Reference\par \pard\plain 
{\tc\tcl2 \v Rectangle}
{\xe \v Rectangle}
{\bkmkstart AAAAAAAAJO}
{\bkmkend AAAAAAAAJO}
\par
{
{\f2 #include <Pose2D.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Pose2D} {\b r1}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Pose2D} {\b r2}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Pose2D} {\b r3}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Pose2D} {\b r4}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Struct to resemble the four corners of a rectangle \par
}{
Definition at line {\b 313} of file {\b Pose2D.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v r1\:Rectangle}
{\xe \v Rectangle\:r1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Pose2D} Rectangle::r1}}
\par
{\bkmkstart AAAAAAAAJP}
{\bkmkend AAAAAAAAJP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 314} of file {\b Pose2D.hpp}.}\par
}
{\xe \v r2\:Rectangle}
{\xe \v Rectangle\:r2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Pose2D} Rectangle::r2}}
\par
{\bkmkstart AAAAAAAAJQ}
{\bkmkend AAAAAAAAJQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 314} of file {\b Pose2D.hpp}.}\par
}
{\xe \v r3\:Rectangle}
{\xe \v Rectangle\:r3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Pose2D} Rectangle::r3}}
\par
{\bkmkstart AAAAAAAAJR}
{\bkmkend AAAAAAAAJR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 314} of file {\b Pose2D.hpp}.}\par
}
{\xe \v r4\:Rectangle}
{\xe \v Rectangle\:r4}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Pose2D} Rectangle::r4}}
\par
{\bkmkstart AAAAAAAAJS}
{\bkmkend AAAAAAAAJS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 314} of file {\b Pose2D.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/home/calebk/Documents/coding/RoombaController/src/{\b Pose2D.hpp}\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Documentation{\tc \v File Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/calebk/Documents/coding/RoombaController/src/Field.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /home/calebk/Documents/coding/RoombaController/src/Field.cpp}
{\xe \v /home/calebk/Documents/coding/RoombaController/src/Field.cpp}
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Field.hpp"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Field.cpp\par \pard\plain 
{\tc\tcl2 \v /home/calebk/Documents/coding/RoombaController/src/Field.cpp}
{\xe \v /home/calebk/Documents/coding/RoombaController/src/Field.cpp}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //}\par
00002 {\cf20 // Created by caleb on 10/25/2024}\par
00003 {\cf20 //}\par
00004 \par
00005 {\cf21 #include "Field.hpp"}\par
00006 \par
00007 Field::Field({\cf17 const} std::vector<Pillar>& pillars, {\cf17 const} Pose2D& desiredDestination, {\cf17 const} Pillar& botPose) \{\par
00008   this->pillars = std::make_unique<std::vector<Pillar>>(pillars);\par
00009     this->desiredDestination = desiredDestination;\par
00010     this->holeManager = HoleManager();\par
00011     this->botPose = botPose;\par
00012     this->graph = Graph<Pose2D>();\par
00013     graph.addNode({\cf17 new} Node<Pose2D>(Pose2D(0, 0)));\par
00014 \}\par
00015 \par
00016 Field::Field({\cf17 const} std::vector<Pillar>& pillars, {\cf17 const} Pose2D& desiredDestination) \{\par
00017     this->pillars = std::make_unique<std::vector<Pillar>>(pillars);\par
00018     this->holeManager = HoleManager();\par
00019     this->desiredDestination = desiredDestination;\par
00020     this->botPose = Pillar(0, 0, 0, BOT_RADIUS);\par
00021     graph.addNode({\cf17 new} Node<Pose2D>(Pose2D(0, 0)));\par
00022 \}\par
00023 \par
00024 Field::Field() \{\par
00025   this-> pillars = std::make_unique<std::vector<Pillar>>();\par
00026   this->desiredDestination = Pose2D(0, 0, 0);\par
00027   this->botPose = Pillar(0, 0, 0, BOT_RADIUS);\par
00028   this->holeManager = HoleManager();\par
00029     graph.addNode({\cf17 new} Node<Pose2D>(Pose2D(0, 0)));\par
00030 \}\par
00031 \par
00032 {\cf18 void} Field::discretizeGraph() \{\par
00033     {\cf19 if} (graph.getNodes().empty()) \{\par
00034         graph.addNode({\cf17 new} Node<Pose2D>(botPose.getPose()));\par
00035     \}\par
00036 \par
00037     {\cf20 // std::vector<Node<Pillar>*> nodes;}\par
00038     {\cf19 for} (Pillar & pillar : newPillars) \{\par
00039         std::vector<Node<Pose2D>*> nodes = graph.getNodes();\par
00040         {\cf19 for} (uint32_t i = 1; i < nodes.size(); i++) \{\par
00041             {\cf19 if} (i != desiredIndex) \{\par
00042                 {\cf19 if} (nodes[i]->getData().distanceTo(pillar.getPose()) < pillar.getRadius() + BOT_RADIUS) \{\par
00043                     {\cf20 // remove node}\par
00044                     graph.removeNode(i);\par
00045                     {\cf20 // nodes = graph.getNodes();}\par
00046                 \}\par
00047             \}\par
00048         \}\par
00049 \par
00050         {\cf18 double} magnitude = pillar.getRadius() + BOT_RADIUS;\par
00051         {\cf19 for} ({\cf18 double} i = 1.0; i < 5.0; i += 0.75) \{\par
00052             {\cf19 for} (uint16_t angle = 0; angle < 361; angle += 25) \{\par
00053                 {\cf17 const} {\cf18 double} radian = angle * M_PI / 180.0;\par
00054                 Pose2D attemptAdd = Pose2D::fromPolar(magnitude * i, radian);\par
00055 \par
00056                 attemptAdd.plus(pillar.getPose());\par
00057 \par
00058                 {\cf19 if} (validLocationForNode(attemptAdd)) \{\par
00059                     {\cf20 // add to list}\par
00060                     Node<Pose2D>* toAdd = {\cf17 new} Node<Pose2D>(attemptAdd);\par
00061 \par
00062                     graph.addNode(toAdd);\par
00063                     {\cf20 // nodes = graph.getNodes();}\par
00064                 \}\par
00065             \}\par
00066         \}\par
00067         this->pillars->push_back(pillar);\par
00068     \}\par
00069     this->newPillars.clear();\par
00070 \par
00071     graph.addNode({\cf17 new} Node<Pose2D>(desiredDestination));\par
00072     desiredIndex = graph.getNodes().size() - 1;\par
00073 \}\par
00074 \par
00075 {\cf18 void} Field::weightGraph() \{\par
00076     std::vector<Node<Pose2D>*> nodes = graph.getNodes();\par
00077     {\cf20 // o(n^3) crying}\par
00078     {\cf19 for} (uint16_t nodeIndex = 0; nodeIndex < nodes.size(); nodeIndex++) \{\par
00079         {\cf19 for} (uint16_t nodeIndexTwo = 0; nodeIndexTwo < nodes.size(); nodeIndexTwo++) \{\par
00080             {\cf19 if} (nodeIndex != nodeIndexTwo) \{\par
00081                 Pose2D positionOne = nodes[nodeIndex]->getData();\par
00082                 Pose2D positionTwo = nodes[nodeIndexTwo]->getData();\par
00083                 {\cf18 double} length = positionOne.distanceTo(positionTwo);\par
00084                 {\cf18 double} dy = (positionTwo.getY() - positionOne.getY());\par
00085                 {\cf18 double} dx = (positionTwo.getX() - positionTwo.getY());\par
00086                 {\cf18 bool} gotThrough = {\cf17 true};\par
00087 \par
00088                 {\cf19 for} (uint8_t pillarIndex = 0; pillarIndex < pillars->size(); pillarIndex++) \{\par
00089                     {\cf19 if} (lineIntersectsCircle(pillars->at(pillarIndex), positionOne, positionTwo)) \{\par
00090                         {\cf20 // uh oh we hit the circle}\par
00091                         gotThrough = {\cf17 false};\par
00092                     \}\par
00093                 \}\par
00094 \par
00095                 {\cf19 if} (holeManager.lineIntersectsAnyHoleMeasurement(positionOne, positionTwo)) \{\par
00096                     gotThrough = {\cf17 false};\par
00097                 \}\par
00098 \par
00099                 {\cf19 if} (gotThrough) \{\par
00100                     {\cf20 // add a weight between nodes[nodeIndex] and nodes[nodeIndexTwo]}\par
00101                     graph.addConnection(nodes[nodeIndex], nodes[nodeIndexTwo], length);\par
00102                     {\cf20 // print out attempt to add}\par
00103                 \}\par
00104             \}\par
00105         \}\par
00106     \}\par
00107 \}\par
00108 \par
00109 std::vector<Pose2D> Field::makePath() \{\par
00110     std::vector<Node<Pose2D>*> path = graph.Dijkstra(graph.getNodes()[0], graph.getNodes()[desiredIndex]);\par
00111     std::vector<Pose2D> toReturn;\par
00112     {\cf19 for} (uint16_t i = 0; i < path.size(); i++) \{\par
00113         toReturn.push_back(path[i]->getData());\par
00114     \}\par
00115     {\cf19 return} toReturn;\par
00116 \}\par
00117 \par
00118 {\cf18 bool} Field::validLocationForNode({\cf17 const} Pose2D& location) \{\par
00119     {\cf19 if} (outOfBounds(location)) \{\par
00120         {\cf19 return} {\cf17 false};\par
00121     \}\par
00122     {\cf19 for} ({\cf17 auto} & i : *pillars) \{\par
00123         {\cf19 if} (i.getPose().distanceTo(location) < i.getRadius() + BOT_RADIUS) \{\par
00124             {\cf19 return} {\cf17 false};\par
00125         \}\par
00126     \}\par
00127     {\cf19 if} (holeManager.nodeCollides(location)) \{\par
00128         {\cf19 return} {\cf17 false};\par
00129     \}\par
00130 \par
00131     {\cf19 return} {\cf17 true};\par
00132 \}\par
00133 \par
00134 HoleManager& Field::getManager() \{\par
00135     {\cf19 return} holeManager;\par
00136 \}\par
00137 \par
00138 {\cf18 void} Field::clearField() \{\par
00139     this->pillars->clear();\par
00140 \}\par
00141 \par
00142 std::unique_ptr<std::vector<Pillar>> Field::getPillars() \{\par
00143     {\cf19 return} std::move(pillars); \par
00144 \}\par
00145 \par
00146 {\cf18 void} Field::setDesiredIndex(int32_t index) \{\par
00147     this->desiredIndex = index;\par
00148 \}\par
00149 \par
00150 \par
00151 {\cf18 void} Field::setPillars(std::unique_ptr<std::vector<Pillar>> pillars) \{\par
00152     this->pillars = std::move(pillars);\par
00153 \} \par
00154 \par
00155 Pillar Field::getBotPose() \{\par
00156     {\cf19 return} botPose;\par
00157 \}\par
00158 \par
00159 {\cf18 void} Field::addPillar(Pillar& newPillar) \{\par
00160     newPillar.setRadius(roundRadius(newPillar.getRadius()));\par
00161 \par
00162     {\cf19 for} (uint32_t i = 0; i < this->pillars->size(); i++) \{\par
00163         {\cf19 if} (this->pillars->at(i).getPose().distanceTo(newPillar.getPose()) < newPillar.getRadius() + this->pillars->at(i).getRadius()) \{\par
00164             {\cf20 // these are the same pillars}\par
00165             Pose2D sum = this->pillars->at(i).getPose();\par
00166             sum.plus(newPillar.getPose());\par
00167             sum.multiply(0.5);\par
00168 \par
00169             Pose2D error = Pose2D(sum);\par
00170             error.minus(this->pillars->at(i).getPose());\par
00171             {\cf19 return};\par
00172         \}\par
00173     \}\par
00174 \par
00175     this->pillars->push_back(newPillar);\par
00176     this->newPillars.push_back(newPillar);\par
00177 \}\par
00178 \par
00179 {\cf18 void} Field::updateBotPose({\cf17 const} Pose2D& updatedPosition) \{\par
00180     Pose2D position(updatedPosition);\par
00181     position.wrapHeading();\par
00182     this->botPose.setPosition(position);\par
00183     {\cf19 if} (!graph.getNodes().empty()) \{\par
00184         graph.getNodes()[0]->SetData(position);\par
00185     \}\par
00186     {\cf19 else} \{\par
00187         graph.addNode({\cf17 new} Node<Pose2D>(position));\par
00188     \}\par
00189 \}\par
00190 \par
00191 std::vector<Pillar> Field::getCopyPillars() \{\par
00192     std::vector<Pillar> copy;\par
00193     {\cf19 for} ({\cf17 const} {\cf17 auto} & i : *pillars) \{\par
00194         copy.push_back(i);\par
00195     \}\par
00196     {\cf19 return} copy;\par
00197 \}\par
00198 \par
00199 {\cf18 bool} Field::outOfBounds({\cf17 const} Pose2D& location) \{\par
00200     {\cf19 return} (location.getX() < 0 || location.getY() < 0 || location.getX() > MAX_X || location.getY() > MAX_Y);\par
00201 \}\par
00202 \par
00203 {\cf18 void} Field::addEdgeMeasurement({\cf17 const} {\cf18 double} rawPosition, {\cf17 const} Cardinality cardinality) \{\par
00204     {\cf19 switch} (cardinality) \{\par
00205         {\cf19 case} N:\par
00206             \{\par
00207                 offset.setY(rawPosition);\par
00208             \}\par
00209             {\cf19 break};\par
00210         {\cf19 case} S:\par
00211             \{\par
00212                 offset.setY(-rawPosition);\par
00213             \}\par
00214             {\cf19 break};\par
00215         {\cf19 case} E:\par
00216             \{\par
00217                 offset.setX(rawPosition);\par
00218             \}\par
00219             {\cf19 break};\par
00220         {\cf19 case} W:\par
00221             \{\par
00222                 offset.setX(-rawPosition);\par
00223             \}\par
00224             {\cf19 break};\par
00225     \}\par
00226 \}\par
00227 \par
00228 {\cf18 void} Field::applyOffsetToEdge({\cf18 double} x, {\cf18 double} y) \{\par
00229     Pose2D offset = Pose2D(x, y);\par
00230     {\cf19 for} (uint16_t i = 0; i < this->pillars->size(); i++) \{\par
00231         this->pillars->at(i).getPose().plus(offset);\par
00232         this->holeManager.offsetAll(offset);\par
00233     \}\par
00234 \}\par
00235 \par
00236 {\cf18 bool} Field::lineIntersectsCircle({\cf18 double} cx, {\cf18 double} cy, {\cf18 double} r, {\cf18 double} x1, {\cf18 double} y1, {\cf18 double} x2, {\cf18 double} y2) \{\par
00237     {\cf20 // Calculate the line direction vector}\par
00238     {\cf18 double} dx = x2 - x1;\par
00239     {\cf18 double} dy = y2 - y1;\par
00240 \par
00241     {\cf20 // Calculate the projection of the circle center onto the line}\par
00242     {\cf18 double} t = ((cx - x1) * dx + (cy - y1) * dy) / (dx * dx + dy * dy);\par
00243 \par
00244     {\cf20 // Find the closest point on the line to the circle center}\par
00245     {\cf18 double} closestX = x1 + t * dx;\par
00246     {\cf18 double} closestY = y1 + t * dy;\par
00247 \par
00248     {\cf20 // Calculate the distance from the circle center to the closest point}\par
00249     {\cf18 double} distX = closestX - cx;\par
00250     {\cf18 double} distY = closestY - cy;\par
00251     {\cf18 double} distanceToLine = std::sqrt(distX * distX + distY * distY);\par
00252 \par
00253     {\cf20 // Check if the distance is less than or equal to the radius}\par
00254     {\cf19 return} distanceToLine <= r;\par
00255 \}\par
00256 \par
00257 int32_t Field::getDesiredIndex(){\cf17  const }\{\par
00258     {\cf19 return} desiredIndex;\par
00259 \}\par
00260 \par
00261 Graph<Pose2D> &Field::getGraph() \{\par
00262     {\cf19 return} graph;\par
00263 \}\par
00264 \par
00265 {\cf18 void} Field::updateDesired({\cf17 const} Pose2D& other) \{\par
00266     {\cf19 if} (desiredIndex != -1) \{\par
00267         graph.removeNode(desiredIndex);\par
00268     \}\par
00269     graph.addNode({\cf17 new} Node<Pose2D>(other));\par
00270     desiredIndex = graph.getNodes().size() - 1;\par
00271     this->desiredDestination = other;\par
00272 \}\par
00273 \par
00274 Pose2D Field::getDesiredDestination() \{\par
00275     {\cf19 return} this->desiredDestination;\par
00276 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/calebk/Documents/coding/RoombaController/src/Field.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v /home/calebk/Documents/coding/RoombaController/src/Field.hpp}
{\xe \v /home/calebk/Documents/coding/RoombaController/src/Field.hpp}
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Pillar.hpp"}\par
{\f2 #include "vector"}\par
{\f2 #include <cstdint>}\par
{\f2 #include <memory>}\par
{\f2 #include "Graph.hpp"}\par
{\f2 #include "HoleManager.hpp"}\par
{\f2 #include "Pose2D.hpp"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Field}}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MAX_X}\~ 426.72\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MAX_Y}\~ 242.57\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b Cardinality} \{ {\b N} = 'N'
, {\b S} = 'S'
, {\b E} = 'E'
, {\b W} = 'W'
 \}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v MAX_X\:Field.hpp}
{\xe \v Field.hpp\:MAX_X}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MAX_X\~ 426.72}}
\par
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
THe max x position on the field \par
}{
Definition at line {\b 20} of file {\b Field.hpp}.}\par
}
{\xe \v MAX_Y\:Field.hpp}
{\xe \v Field.hpp\:MAX_Y}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MAX_Y\~ 242.57}}
\par
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The max y position on the field \par
}{
Definition at line {\b 25} of file {\b Field.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v Cardinality\:Field.hpp}
{\xe \v Field.hpp\:Cardinality}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b Cardinality}}}
\par
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Norht, South, East, West \par
}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v N\:Field.hpp}
{\xe \v Field.hpp\:N}
{\qr N{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
\cell }{\cell }{\row }
{\xe \v S\:Field.hpp}
{\xe \v Field.hpp\:S}
{\qr S{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
\cell }{\cell }{\row }
{\xe \v E\:Field.hpp}
{\xe \v Field.hpp\:E}
{\qr E{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
\cell }{\cell }{\row }
{\xe \v W\:Field.hpp}
{\xe \v Field.hpp\:W}
{\qr W{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 30} of file {\b Field.hpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Field.hpp\par \pard\plain 
{\tc\tcl2 \v /home/calebk/Documents/coding/RoombaController/src/Field.hpp}
{\xe \v /home/calebk/Documents/coding/RoombaController/src/Field.hpp}
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //}\par
00002 {\cf20 // Created by caleb on 10/25/2024}\par
00003 {\cf20 //}\par
00004 \par
00005 {\cf21 #ifndef FIELD_H}\par
00006 {\cf21 #define FIELD_H}\par
00007 \par
00008 {\cf21 #include "Pillar.hpp"}\par
00009 {\cf21 #include "vector"}\par
00010 {\cf21 #include <cstdint>} \par
00011 {\cf21 #include <memory>}\par
00012 \par
00013 {\cf21 #include "Graph.hpp"}\par
00014 {\cf21 #include "HoleManager.hpp"}\par
00015 {\cf21 #include "Pose2D.hpp"}\par
00016 \par
00020 {\cf21 #define MAX_X 426.72}\par
00021 \par
00025 {\cf21 #define MAX_Y 242.57}\par
00026 \par
00030 {\cf17 enum} Cardinality \{\par
00031     N = {\cf23 'N'},\par
00032     S = {\cf23 'S'},\par
00033     E = {\cf23 'E'},\par
00034     W = {\cf23 'W'},\par
00035 \};\par
00036 \par
00040 {\cf17 class }Field \{\par
00041   {\cf17 protected}:\par
00046  std::unique_ptr<std::vector<Pillar>> pillars;\par
00047 \par
00051  HoleManager holeManager;\par
00052 \par
00057  Pose2D offset;\par
00058 \par
00062  Pose2D desiredDestination;\par
00063 \par
00067  Pillar botPose;\par
00068 \par
00073  Pose2D runningError;\par
00074 \par
00082  Graph<Pose2D> graph;\par
00083 \par
00087  int32_t desiredIndex = -1;\par
00088 \par
00093  std::vector<Pillar> newPillars;\par
00094     \par
00095   {\cf17 public}:\par
00102     Field({\cf17 const} std::vector<Pillar>& pillars, {\cf17 const} Pose2D& desiredDestination, {\cf17 const} Pillar& botPose);\par
00103 \par
00109     Field({\cf17 const} std::vector<Pillar>& pillars, {\cf17 const} Pose2D& desiredDestination);\par
00110 \par
00114     Field();\par
00115 \par
00123     Field({\cf17 const} std::unique_ptr<std::vector<Pillar>> &pillars, {\cf17 const} Pose2D &desired_destination,\par
00124           {\cf17 const} Pillar &bot_pose, {\cf17 const} Graph<Pose2D> &graph);\par
00125 \par
00131  {\cf18 void} addEdgeMeasurement({\cf18 double} rawPosition, Cardinality cardinality);\par
00132 \par
00137  HoleManager& getManager();\par
00138 \par
00144  {\cf18 void} applyOffsetToEdge({\cf18 double} x, {\cf18 double} y);\par
00145 \par
00149  [[nodiscard]] int32_t getDesiredIndex() {\cf17 const};\par
00150 \par
00154  {\cf18 void} clearField();\par
00155 \par
00160  Graph<Pose2D>& getGraph();\par
00161 \par
00165  Pillar getBotPose();\par
00166 \par
00172  {\cf17 static} {\cf18 bool} outOfBounds({\cf17 const} Pose2D& location);\par
00173 \par
00177     {\cf17 static} {\cf18 bool} lineIntersectsCircle({\cf18 double} cx, {\cf18 double} cy, {\cf18 double} r, {\cf18 double} x1, {\cf18 double} y1, {\cf18 double} x2, {\cf18 double} y2);\par
00178 \par
00182  {\cf17 static} {\cf18 bool} lineIntersectsCircle(Pillar p1, {\cf17 const} Pose2D& one, {\cf17 const} Pose2D& two) \{{\cf19 return} lineIntersectsCircle(p1.getX(), p1.getY(), p1.getRadius() + BOT_RADIUS, one.getX(), one.getY(), two.getX(), two.getY()); \}\par
00183 \par
00187  {\cf18 void} discretizeGraph();\par
00188 \par
00192  {\cf18 void} weightGraph();\par
00193 \par
00198  std::vector<Pose2D> makePath();\par
00199 \par
00204  {\cf18 void} addPillar(Pillar& newPillar);\par
00205 \par
00210     {\cf18 void} updateBotPose({\cf17 const} Pose2D& updatedPosition);\par
00211 \par
00216     std::unique_ptr<std::vector<Pillar>> getPillars();\par
00217 \par
00222     {\cf18 void} setPillars(std::unique_ptr<std::vector<Pillar>> pillars);\par
00223 \par
00227     std::vector<Pillar> getCopyPillars();\par
00228 \par
00234     {\cf18 bool} validLocationForNode({\cf17 const} Pose2D& location);\par
00235 \par
00240     Pose2D getDesiredDestination();\par
00241 \par
00245     {\cf18 void} updateDesired({\cf17 const} Pose2D& other);\par
00246 \par
00251     {\cf18 void} setDesiredIndex(int32_t index);\par
00252 \par
00258     {\cf17 static} {\cf18 double} roundRadius({\cf18 double} radius) \{\par
00259         {\cf17 const} {\cf18 double} possibleRadii[] = \{5.1, 7.62, 10.16, 12.7\};\par
00260         {\cf18 double} closest = possibleRadii[0];\par
00261         {\cf18 double} minDiff = std::abs(radius - possibleRadii[0]);\par
00262 \par
00263         {\cf19 for} ({\cf18 double} r : possibleRadii) \{\par
00264             {\cf18 double} diff = std::abs(radius - r);\par
00265             {\cf19 if} (diff < minDiff) \{\par
00266                 minDiff = diff;\par
00267                 closest = r;\par
00268             \}\par
00269         \}\par
00270         {\cf19 return} closest;\par
00271     \}\par
00272 \par
00273     \};\par
00274 \par
00275 {\cf21 #endif }{\cf20 //FIELD_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/calebk/Documents/coding/RoombaController/src/Graph.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /home/calebk/Documents/coding/RoombaController/src/Graph.cpp}
{\xe \v /home/calebk/Documents/coding/RoombaController/src/Graph.cpp}
{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Graph.hpp"}\par
{\f2 #include <iostream>}\par
{\f2 #include <queue>}\par
{\f2 #include <cstdlib>}\par
{\f2 #include <ctime>}\par
{\f2 #include "limits.h"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Graph.cpp\par \pard\plain 
{\tc\tcl2 \v /home/calebk/Documents/coding/RoombaController/src/Graph.cpp}
{\xe \v /home/calebk/Documents/coding/RoombaController/src/Graph.cpp}
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //}\par
00002 {\cf20 // Created by caleb on 11/9/21.}\par
00003 {\cf20 //}\par
00004 \par
00005 {\cf21 #include "Graph.hpp"}\par
00006 \par
00007 {\cf21 #include <iostream>}\par
00008 {\cf21 #include <queue>}\par
00009 {\cf21 #include <cstdlib>}\par
00010 {\cf21 #include <ctime>}\par
00011 {\cf21 #include "limits.h"}\par
00012 \par
00013 {\cf17 template}<{\cf17 typename} V>\par
00014 Graph<V>::Graph() \{\par
00015     std::vector<double> temp;\par
00016     temp.push_back(0);\par
00017     temp.push_back(0);\par
00018     matrix.push_back(temp);\par
00019     matrix.push_back(temp);\par
00020 \}\par
00021 \par
00022 {\cf20 /*}\par
00023 {\cf20 template<typename V>}\par
00024 {\cf20 void Graph<V>::playGround() \{}\par
00025 {\cf20     Node<V> *tempNode = new Node<V>(0);}\par
00026 {\cf20     addNode(tempNode);}\par
00027 {\cf20     // srand(time(0));}\par
00028 {\cf20 }\par
00029 {\cf20     addNode(new Node<V>(1), nodes[0], 2);}\par
00030 {\cf20     addNode(new Node<V>(2), nodes[1], 1);}\par
00031 {\cf20     addNode(new Node<V>(3), nodes[2], 3);}\par
00032 {\cf20     addNode(new Node<V>(4), nodes[0], 2);}\par
00033 {\cf20     addConnection(nodes[4], nodes[2], 3);}\par
00034 {\cf20     addNode(new Node<V>(5), nodes[1], 2);}\par
00035 {\cf20     addNode(new Node<V>(6), nodes[1], 1);}\par
00036 {\cf20     addConnection(nodes[5], nodes[3], 7);}\par
00037 {\cf20     addNode(new Node<V>(7), nodes[2], 5);}\par
00038 {\cf20     addNode(new Node<V>(8), nodes[6], 5);}\par
00039 {\cf20     addConnection(nodes[8], nodes[3], 3);}\par
00040 {\cf20     addNode(new Node<V>(9), nodes[8], 1);}\par
00041 {\cf20     addConnection(nodes[9], nodes[7], 8);}\par
00042 {\cf20 }\par
00043 {\cf20 }\par
00044 {\cf20     head = nodes[0];}\par
00045 {\cf20 }\par
00046 {\cf20 }\par
00047 {\cf20     // printOut();}\par
00048 {\cf20 }\par
00049 {\cf20     printAdjacent(head);}\par
00050 {\cf20 }\par
00051 {\cf20     std::cout << std::endl;}\par
00052 {\cf20 }\par
00053 {\cf20     std::vector<Node<V>*> path = Dijkstra(nodes[7]);}\par
00054 {\cf20 }\par
00055 {\cf20     std::cout << "goal: " << nodes[7]->getData() << std::endl;}\par
00056 {\cf20 }\par
00057 {\cf20     std::cout << "\\n\\n\\n Path: ";}\par
00058 {\cf20     if (!path.empty()) \{}\par
00059 {\cf20         for (int looper = 0; looper < path.size(); looper++) \{}\par
00060 {\cf20             if (looper != path.size() - 1) \{}\par
00061 {\cf20                 std::cout << nodeMap.at(path[looper]) << "->";}\par
00062 {\cf20             \} else \{}\par
00063 {\cf20                 std::cout << nodeMap.at(path[looper]);}\par
00064 {\cf20             \}}\par
00065 {\cf20         \}}\par
00066 {\cf20         std::cout << std::endl;}\par
00067 {\cf20     \}}\par
00068 {\cf20 }\par
00069 {\cf20 /*    std::cout << "\\n\\n\\n Vals: " << std::endl;}\par
00070 {\cf20     for (int i = 0; i < nodes.size(); i++) \{}\par
00071 {\cf20         std::cout << i << " -> " << nodes[i] << std::endl;}\par
00072 {\cf20     \}*/}\par
00073 \par
00074 \par
00075 {\cf20 // \}}\par
00076 \par
00077 \par
00078 {\cf17 template}<{\cf17 typename} V>\par
00079 {\cf18 void} Graph<V>::resize() \{\par
00080     matrix.resize(nodes.size());\par
00081     {\cf19 for} (std::vector<double>& looper : matrix) \{\par
00082         looper.resize(nodes.size());\par
00083     \}\par
00084 \}\par
00085 \par
00086 {\cf17 template}<{\cf17 typename} V>\par
00087 {\cf18 bool} Graph<V>::contains(Node<V>* node, std::vector<Node<V>*> listOfNodes) \{\par
00088     {\cf19 for} ({\cf18 int} looper = 0; looper < listOfNodes.size(); looper++) \{\par
00089         {\cf19 if} (node == listOfNodes[looper]) \{\par
00090             {\cf19 return} {\cf17 true};\par
00091         \}\par
00092     \}\par
00093     {\cf19 return} {\cf17 false};\par
00094 \}\par
00095 \par
00096 {\cf17 template}<{\cf17 typename} V>\par
00097 std::vector<Node<V>*> Graph<V>::getNodes() \{\par
00098     {\cf19 return} this->nodes;\par
00099 \}\par
00100 \par
00101 {\cf17 template}<{\cf17 typename} V>\par
00102 {\cf18 void} Graph<V>::addNode(Node<V>* newNode) \{\par
00103     {\cf19 if} (contains(newNode, nodes)) \{{\cf19 return};\}\par
00104     head = newNode;\par
00105     nodes.push_back(newNode);\par
00106     nodeMap[newNode] = nodes.size() - 1;\par
00107     resize();\par
00108 \}\par
00109 \par
00110 {\cf17 template}<{\cf17 typename} V>\par
00111 {\cf18 void} Graph<V>::addNode(Node<V>* nextNode, std::vector<Node<V>*> adjacentNodes, {\cf18 double} weight) \{\par
00112     addNode(nextNode);\par
00113     {\cf19 for} ({\cf18 int} looper = 0; looper < adjacentNodes.size(); looper++) \{\par
00114         {\cf19 if} (!contains(adjacentNodes[looper], nodes)) \{\par
00115             nodes.push_back(adjacentNodes[looper]);\par
00116             nodeMap[adjacentNodes[looper]] = nodes.size() - 1;\par
00117         \}\par
00118         resize();\par
00119         {\cf18 int} currNodeNum = nodeMap.at(nextNode);\par
00120         {\cf18 int} nextNodeNum = nodeMap.at(adjacentNodes[looper]);\par
00121         matrix[currNodeNum][nextNodeNum] = weight;\par
00122         matrix[nextNodeNum][currNodeNum] = weight;\par
00123     \}\par
00124 \}\par
00125 \par
00126 {\cf17 template}<{\cf17 typename} V>\par
00127 {\cf18 void} Graph<V>::addNode(Node<V> *nextNode, std::vector<Node<V>*> adjacentNodes) \{\par
00128     addNode(nextNode, adjacentNodes, 1);\par
00129 \}\par
00130 \par
00131 {\cf17 template}<{\cf17 typename} V>\par
00132 {\cf18 void} Graph<V>::addNode(Node<V> *nextNode, Node<V> *nodeITSLATE) \{\par
00133     std::vector<Node<V>*> adj;\par
00134     adj.push_back(nodeITSLATE);\par
00135     addNode(nextNode, adj);\par
00136 \}\par
00137 \par
00138 {\cf20 /*}\par
00139 {\cf20 template<typename V>}\par
00140 {\cf20 void Graph<V>::printOut() \{}\par
00141 {\cf20     for (int looper = 0; looper < nodes.size(); looper++) \{}\par
00142 {\cf20         if (looper != nodes.size() - 1) \{}\par
00143 {\cf20             std::cout << nodes[looper]->getData() << ", ";}\par
00144 {\cf20         \}}\par
00145 {\cf20         else \{}\par
00146 {\cf20             std::cout << nodes[looper]->getData();}\par
00147 {\cf20         \}}\par
00148 {\cf20     \}}\par
00149 {\cf20     std::cout << std::endl;}\par
00150 {\cf20 }\par
00151 {\cf20     for (int anotherLoop = 0; anotherLoop < nodes.size(); anotherLoop++) \{}\par
00152 {\cf20         std::cout << "-";}\par
00153 {\cf20     \}}\par
00154 {\cf20     std::cout << std::endl;}\par
00155 {\cf20 }\par
00156 {\cf20     for (int i = 0; i < matrix.size(); i++) \{}\par
00157 {\cf20         for (int ii = 0; ii < matrix[i].size(); ii++) \{}\par
00158 {\cf20             if (ii != matrix.size() - 1) \{}\par
00159 {\cf20                 std::cout << matrix[i][ii] << ", ";}\par
00160 {\cf20             \}}\par
00161 {\cf20             else \{}\par
00162 {\cf20                 std::cout << matrix[i][ii];}\par
00163 {\cf20             \}}\par
00164 {\cf20         \}}\par
00165 {\cf20         std::cout << std::endl;}\par
00166 {\cf20     \}}\par
00167 {\cf20     std::cout << "\\n\\n\\n" << std::endl;}\par
00168 {\cf20 \}}\par
00169 {\cf20 */}\par
00170 \par
00171 {\cf17 template}<{\cf17 typename} V>\par
00172 std::vector<Node<V>*> Graph<V>::getAdj(Node<V>* next) \{\par
00173     std::vector<Node<V>*> adjacent;\par
00174     {\cf18 int} index = nodeMap.at(next);\par
00175 \par
00176     {\cf19 for} ({\cf18 int} looper = 0; looper < matrix.size(); looper++) \{\par
00177         {\cf19 if} (matrix[index][looper] != 0) \{\par
00178             adjacent.push_back(nodes[looper]);\par
00179         \}\par
00180     \}\par
00181     {\cf19 return} adjacent;\par
00182 \}\par
00183 \par
00184 {\cf17 template}<{\cf17 typename} V>\par
00185 {\cf18 void} Graph<V>::setHead({\cf18 int} index) \{\par
00186     head = getNodes()[index];\par
00187 \}\par
00188 \par
00189 \par
00190 {\cf17 template}<{\cf17 typename} V>\par
00191 std::vector<Node<V>*> Graph<V>::Dijkstra(Node<V>* from, Node<V>* find) \{\par
00192     std::vector<Node<V>*> thing;\par
00193     {\cf19 if} (from == find) \{\par
00194     {\cf20 // std::cout << "was head" << std::endl;}\par
00195         {\cf19 return} thing;\par
00196     \}\par
00197     std::vector<bool> visited;\par
00198     visited.resize(nodes.size());\par
00199     {\cf18 double} distances[nodes.size()];\par
00200 \par
00201     {\cf19 for}({\cf18 int} filler = 0; filler < nodes.size(); filler++) \{\par
00202         visited[filler] = 0;\par
00203         distances[filler] = UINT_MAX;\par
00204     \}\par
00205     distances[0] = 0;\par
00206 \par
00207     std::priority_queue<pair, std::vector<pair>, CustomCompare> queue;\par
00208     std::vector<Node<V>*> temp;\par
00209     temp.push_back(from);\par
00210     queue.push(std::pair<{\cf18 double}, std::vector<Node<V>*>>(0, temp));\par
00211     uint64_t iterations = 0;\par
00212 \par
00213     {\cf19 while} (!queue.empty()) \{\par
00214         iterations++;\par
00215 \par
00216         std::vector<Node<V>*> path = queue.top().second;        \par
00217         Node<V> *curr = path[path.size() - 1];\par
00218         {\cf18 double} currentDistance = queue.top().first;\par
00219         queue.pop();\par
00220 \par
00221         visited[nodeMap.at(curr)] = 1;\par
00222 \par
00223         {\cf19 if} (find == curr) \{\par
00224             {\cf20 // std::cout << "\\n\\nDistance: " << currentDistance << std::endl;}\par
00225             std::cout << iterations << std::endl;\par
00226             {\cf19 return} path;\par
00227         \}\par
00228 \par
00229         std::vector<Node<V>*> adj = getAdj(curr);\par
00230 \par
00231         {\cf19 for} ({\cf18 int} looper = 0; looper < adj.size(); looper++) \{\par
00232             std::vector<Node<V>*> possiblePath;\par
00233             {\cf19 for} ({\cf18 int} i = 0; i < path.size(); i++) \{\par
00234                 possiblePath.push_back(path[i]);\par
00235             \}\par
00236             {\cf20 // printAdjacent(curr);}\par
00237             {\cf19 if} (!visited[nodeMap.at(adj[looper])] && currentDistance + matrix[nodeMap.at(curr)][nodeMap.at(adj[looper])] < distances[nodeMap.at(adj[looper])]) \{\par
00238                 distances[nodeMap.at(adj[looper])] = currentDistance + matrix[nodeMap.at(curr)][nodeMap.at(adj[looper])];\par
00239                 possiblePath.push_back(adj[looper]);\par
00240                 queue.push(std::pair<{\cf18 double}, std::vector<Node<V>*>>(currentDistance + matrix[nodeMap.at(curr)][nodeMap.at(adj[looper])], possiblePath));\par
00241             \}\par
00242         \}\par
00243         thing = path;\par
00244     \}\par
00245 \par
00246     {\cf20 // std::cout << "ATTEMPT TO RETURN SIZE: " << thing.size() << std::endl;}\par
00247    {\cf20 //  delete queue;}\par
00248     {\cf20 // delete[] distances;}\par
00249     std::cout << iterations << std::endl;\par
00250     {\cf19 return} thing;\par
00251 \}\par
00252 \par
00253 {\cf17 template}<{\cf17 typename} V>\par
00254 Graph<V>::~Graph() \{\par
00255     {\cf20 // delete all connections and nodes}\par
00256     {\cf19 for} (Node<V>* node : nodes) \{\par
00257     {\cf17 delete} node;\par
00258     \}\par
00259 \}\par
00260 \par
00261 {\cf17 template}<{\cf17 typename} V>\par
00262 std::vector<std::vector<double>> Graph<V>::getAdjacencyList() \{\par
00263     {\cf19 return} matrix;\par
00264 \}\par
00265 \par
00266 {\cf17 template}<{\cf17 typename} V>\par
00267 {\cf18 void} Graph<V>::addConnection(Node<V> *one, Node<V> *two, {\cf18 double} weight) \{\par
00268     {\cf18 int} oneIndex = nodeMap.at(one);\par
00269     {\cf18 int} twoIndex = nodeMap.at(two);\par
00270 \par
00271     matrix[oneIndex][twoIndex] = weight;\par
00272     matrix[twoIndex][oneIndex] = weight;\par
00273 \par
00274 \}\par
00275 \par
00276 {\cf17 template}<{\cf17 typename} V>\par
00277 {\cf18 void} Graph<V>::addConnection(Node<V> *one, Node<V> *two) \{\par
00278     addConnection(one, two, 1);\par
00279 \}\par
00280 \par
00281 {\cf17 template}<{\cf17 typename} V>\par
00282 {\cf18 void} Graph<V>::addNode(Node<V> *nextNode, Node<V> *nodeITSLATE, {\cf18 double} weight) \{\par
00283     std::vector<Node<V>*> adj;\par
00284     adj.push_back(nodeITSLATE);\par
00285     addNode(nextNode, adj, weight);\par
00286 \}\par
00287 \par
00288 {\cf17 template}<{\cf17 typename} V>\par
00289 {\cf18 int} Graph<V>::numVisited(std::vector<bool> listOfBools) \{\par
00290     {\cf18 int} counter = 0;\par
00291     {\cf19 for} ({\cf18 int} i = 0; i < listOfBools.size(); i++) \{\par
00292         {\cf19 if} (listOfBools[i]) \{\par
00293             counter++;\par
00294         \}\par
00295     \}\par
00296     {\cf19 return} counter;\par
00297 \}\par
00298 \par
00299 {\cf20 /*}\par
00300 {\cf20 template<typename V>}\par
00301 {\cf20 void Graph<V>::printAdjacent(Node<V>* next) \{}\par
00302 {\cf20     std::vector<Node<V>*> list = getAdj(next);}\par
00303 {\cf20     std::cout << "current: " << next->getData() << std::endl;}\par
00304 {\cf20 }\par
00305 {\cf20     std::cout << "Adjacent nodes: ";}\par
00306 {\cf20     for (int looper = 0; looper < list.size(); looper++) \{}\par
00307 {\cf20         std::cout << nodeMap.at(list[looper]);}\par
00308 {\cf20         if (looper != list.size() - 1) \{}\par
00309 {\cf20             std::cout << ", ";}\par
00310 {\cf20         \}}\par
00311 {\cf20     \}}\par
00312 {\cf20     std::cout << std::endl;}\par
00313 {\cf20 \}}\par
00314 {\cf20 */}\par
00315 {\cf20 /*}\par
00316 {\cf20 template<typename V> }\par
00317 {\cf20 std::vector<Node<V>*> Graph<V>::FrugalKugel(Node<V>* find, unsigned int steps) \{}\par
00318 {\cf20     std::vector<Node<V>*> toReturn;}\par
00319 {\cf20     if (head == find) \{}\par
00320 {\cf20         return toReturn;}\par
00321 {\cf20     \}}\par
00322 {\cf20     std::vector<bool> visited;}\par
00323 {\cf20     visited.resize(nodes.size());}\par
00324 {\cf20     unsigned int distances[nodes.size()];}\par
00325 {\cf20 }\par
00326 {\cf20     // set distances except for the first one to infinity}\par
00327 {\cf20     for (int filler = 1; filler < nodes.size(); filler++) \{}\par
00328 {\cf20         distances[filler] = UINT_MAX;}\par
00329 {\cf20     \}}\par
00330 {\cf20     distances[0] = 0;}\par
00331 {\cf20 }\par
00332 {\cf20     // setup a prioirty queue}\par
00333 {\cf20     std::priority_queue<pair, std::vector<pair>, CustomCompare> queue;}\par
00334 {\cf20     std::vector<Node<V>*> temp;}\par
00335 {\cf20     temp.push_back(head);}\par
00336 {\cf20     queue.push(std::pair<unsigned int, std::vector<Node<V>*>>(0, temp));}\par
00337 {\cf20 }\par
00338 {\cf20     while (!queue.empty()) \{}\par
00339 {\cf20         // get the path from the top of the queue}\par
00340 {\cf20         std::vector<Node<V>*> path = queue.top().second;}\par
00341 {\cf20         // get the most recent item added to the path}\par
00342 {\cf20         Node<V>* curr = path[path.size() - 1];}\par
00343 {\cf20         unsigned int currentDistance = queue.top().first;}\par
00344 {\cf20         // remove the current path from the PQ}\par
00345 {\cf20         queue.pop();}\par
00346 {\cf20 }\par
00347 {\cf20         visited[nodeMap.at(curr)] = 1;}\par
00348 {\cf20 }\par
00349 {\cf20         // found the goal node}\par
00350 {\cf20         if (find == curr) \{}\par
00351 {\cf20             std::cout << "\\nDistance: " << currentDistance << std::endl;}\par
00352 {\cf20             return path;}\par
00353 {\cf20         \}}\par
00354 {\cf20 }\par
00355 {\cf20         std::vector<Node<V>*>& adj = nodes[nodeMap.at(curr)];}\par
00356 {\cf20 }\par
00357 {\cf20         for (int looper = 0; looper <  adj.size(); looper++) \{}\par
00358 {\cf20             if (adj[looper] != 0) \{}\par
00359 {\cf20                 std::vector<Node<V>*> possiblePath;}\par
00360 {\cf20                 // copy over every element from path}\par
00361 {\cf20                 for (int i = 0; i < path.size(); i++) \{}\par
00362 {\cf20                     possiblePath.push_back(path[i]);}\par
00363 {\cf20                 \}}\par
00364 {\cf20                 // print the adjacent nodes}\par
00365 {\cf20                 printAdjacent(curr);}\par
00366 {\cf20                 // cache the index}\par
00367 {\cf20                 int index = nodeMap.at(adj[looper]);}\par
00368 {\cf20                 // the weight between the current node and the node we ate checking}\par
00369 {\cf20                 double tempDistance  = ((path.size() < 2) ? INT_MAX : matrix[nodeMap.at(curr)][index]);}\par
00370 {\cf20                 double sumDistance = tempDistance + currentDistance;}\par
00371 {\cf20                 // checks if we have visited the node we are inspecting, the distance is less than the cirrent distance, and}\par
00372 {\cf20                 if (!visited[index] && sumDistance < distances[index]) \{}\par
00373 {\cf20                     distances[index] = sumDistance;}\par
00374 {\cf20                     possiblePath.push_back(adj[looper]);}\par
00375 {\cf20                     queue.push(std::pair<unsigned int, std::vector<Node<V>*>>(sumDistance, possiblePath));}\par
00376 {\cf20                 \}}\par
00377 {\cf20             \}}\par
00378 {\cf20         \}}\par
00379 {\cf20         toReturn = path;}\par
00380 {\cf20     \}}\par
00381 {\cf20     delete queue;}\par
00382 {\cf20     delete[] distances;}\par
00383 {\cf20     return toReturn;}\par
00384 {\cf20 \}}\par
00385 {\cf20 }\par
00386 {\cf20 */}\par
00387 \par
00388 \par
00389 {\cf17 template}<{\cf17 typename} V>\par
00390 {\cf18 void} Graph<V>::removeNode({\cf18 size_t} index) \{\par
00391     {\cf19 if} (index >= nodes.size()) \{\par
00392         {\cf19 return};\par
00393     \}\par
00394     {\cf17 delete} nodes.at(index);\par
00395     nodes.erase(nodes.begin() + index);\par
00396     resize();\par
00397 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/calebk/Documents/coding/RoombaController/src/Graph.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v /home/calebk/Documents/coding/RoombaController/src/Graph.hpp}
{\xe \v /home/calebk/Documents/coding/RoombaController/src/Graph.hpp}
{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Node.hpp"}\par
{\f2 #include "Pose2D.hpp"}\par
{\f2 #include <stack>}\par
{\f2 #include "vector"}\par
{\f2 #include "map"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Graph< V >}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Graph< V >::CustomCompare}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Graph.hpp\par \pard\plain 
{\tc\tcl2 \v /home/calebk/Documents/coding/RoombaController/src/Graph.hpp}
{\xe \v /home/calebk/Documents/coding/RoombaController/src/Graph.hpp}
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //}\par
00002 {\cf20 // Created by caleb on 11/9/21.}\par
00003 {\cf20 //}\par
00004 \par
00005 {\cf21 #ifndef ANOTHERGRAPH_GRAPH_H}\par
00006 {\cf21 #define ANOTHERGRAPH_GRAPH_H}\par
00007 \par
00008 {\cf21 #include "Node.hpp"}\par
00009 {\cf21 #include "Pose2D.hpp"}\par
00010 {\cf21 #include <stack>}\par
00011 \par
00012 {\cf21 #include "vector"}\par
00013 {\cf21 #include "map"}\par
00014 \par
00015 \par
00016 {\cf17 template} <{\cf17 typename} V>\par
00017 {\cf17 class }Graph \{\par
00018     {\cf17 protected}:\par
00019         {\cf17 typedef} std::pair<double, std::vector<Node<V>*>> pair;\par
00020         {\cf17 struct }CustomCompare \{\par
00021             {\cf18 bool} operator()({\cf17 const} pair& first, {\cf17 const} pair& second) \{\par
00022                 {\cf19 return} first.first > second.first;\par
00023             \}\par
00024         \};\par
00025         std::vector<Node<V>*> nodes;\par
00026         std::vector<std::vector<double>> matrix;\par
00027         Node<V>* head = {\cf17 nullptr};\par
00028         std::map<Node<V>*, {\cf18 unsigned} {\cf18 int}> nodeMap;\par
00029 \par
00030 \par
00034         {\cf18 void} resize();\par
00035 \par
00041         {\cf18 int} numVisited(std::vector<bool> listOfBools);\par
00042 \par
00049         {\cf18 bool} contains(Node<V>* node, std::vector<Node<V>*> listOfNodes);\par
00050 \par
00051         {\cf20 //void printAdjacent(Node<V>* next);}\par
00052 \par
00053     {\cf17 public}:\par
00058         {\cf18 void} addNode(Node<V>* newNode);\par
00059 \par
00060     {\cf20 // void printOut();}\par
00061 \par
00068         {\cf18 void} addNode(Node<V>* nextNode, std::vector<Node<V>*> adjacentNodes, {\cf18 double} weight);\par
00069 \par
00075         {\cf18 void} addNode(Node<V> *nextNode, std::vector<Node<V>*> adjacentNodes);\par
00076 \par
00082         {\cf18 void} addNode(Node<V> *nextNode, Node<V> *nodeITSLATE);\par
00083 \par
00090         {\cf18 void} addConnection(Node<V> *one, Node<V> *two, {\cf18 double} weight);\par
00091 \par
00097         {\cf18 void} addConnection(Node<V> *one, Node<V> *two);\par
00098 \par
00105         {\cf18 void} addNode(Node<V> *nextNode, Node<V> *nodeITSLATE, {\cf18 double} weight);\par
00106 \par
00111         {\cf18 void} setHead({\cf18 int} index);\par
00112 \par
00117         {\cf18 void} removeNode({\cf18 size_t} index);\par
00118 \par
00125         std::vector<Node<V>*> Dijkstra(Node<V>* from, Node<V>* find);\par
00126 \par
00131         std::vector<std::vector<double>> getAdjacencyList();\par
00132 \par
00138         std::vector<Node<V>*> getAdj(Node<V>* next);\par
00139 \par
00143         std::vector<Node<V>*> getNodes();\par
00144 \par
00145     {\cf20 // void playGround();}\par
00146 \par
00147         Graph();\par
00148 \par
00149         {\cf20 // std::vector<Node<V>*> FrugalKugel(Node<V>* find, unsigned int steps);}\par
00150 \par
00151     ~Graph();\par
00152 \par
00153 \};\par
00154 \par
00155 {\cf17 template} {\cf17 class }Graph<Pose2D>;\par
00156 \par
00157 \par
00158 {\cf21 #endif }{\cf20 //ANOTHERGRAPH_GRAPH_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/calebk/Documents/coding/RoombaController/src/Hole.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /home/calebk/Documents/coding/RoombaController/src/Hole.cpp}
{\xe \v /home/calebk/Documents/coding/RoombaController/src/Hole.cpp}
{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <iostream>}\par
{\f2 #include "Hole.hpp"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &os, const {\b Hole} &hole)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v operator<<\:Hole.cpp}
{\xe \v Hole.cpp\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & operator<< (std::ostream &  {\i os}, const {\b Hole} &  {\i hole})}}
\par
{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Override output stream for printing {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i os} \cell }{output stream \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i hole} \cell }{the hole to print \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
the hole printed in the out stream \par
}}}{
Definition at line {\b 373} of file {\b Hole.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Hole.cpp\par \pard\plain 
{\tc\tcl2 \v /home/calebk/Documents/coding/RoombaController/src/Hole.cpp}
{\xe \v /home/calebk/Documents/coding/RoombaController/src/Hole.cpp}
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00005 {\cf21 #include <iostream>}\par
00006 {\cf21 #include "Hole.hpp"}\par
00007 \par
00008 \par
00009 Hole::Hole({\cf17 const} Pose2D& positionOne, {\cf17 const} Pose2D& positionTwo, {\cf18 double} holeSize) \{\par
00010     Pose2D o1 = positionOne.clone();\par
00011     Pose2D o2 = positionTwo.clone();\par
00012     threshold = o1.distanceTo(o2) / sqrt(2);\par
00013     this->holeSize = holeSize;\par
00014     this->registerPointsToHole(o1, o2);\par
00015     this->points = std::make_unique<std::vector<Pose2D>>();\par
00016     this->pointHoles = std::make_unique<std::vector<Hole>>();\par
00017 \}\par
00018 \par
00019 Hole::Hole({\cf17 const} Pose2D& positionOne, {\cf17 const} Pose2D& positionTwo, {\cf18 bool} foundHole, {\cf17 const} std::vector<Pose2D>& points, {\cf18 double} holeSize) \{\par
00020     threshold = positionOne.distanceTo(positionTwo) / sqrt(2);\par
00021     {\cf19 if} (foundHole) \{\par
00022         this->registerPointsToHole(positionOne, positionTwo);\par
00023     \}\par
00024     {\cf19 else} \{\par
00025         this->foundHole = {\cf17 false};\par
00026     \}\par
00027 \par
00028     this->points = std::make_unique<std::vector<Pose2D>>();\par
00029     {\cf19 for} ({\cf17 const} {\cf17 auto} & point : points) \{\par
00030         this->points->push_back(point);\par
00031     \}\par
00032     this->pointHoles = std::make_unique<std::vector<Hole>>();\par
00033 \}\par
00034 \par
00035 Pose2D Hole::getOneSquareCorner() \{\par
00036     {\cf19 return} this->cornerOne;\par
00037 \}\par
00038 \par
00039 Pose2D Hole::getSecondSquareCorner() \{\par
00040     {\cf19 return} this->cornerTwo;\par
00041 \}\par
00042 \par
00043 Pose2D Hole::copyDoOperation({\cf17 const} Pose2D& position){\cf17  const }\{\par
00044     Pose2D center(this->cornerOne);\par
00045     center.setHeading(center.angleTo(this->cornerTwo));\par
00046     center.translateByMagnitude(center.distanceTo(this->cornerTwo) / 2);\par
00047 \par
00048     Pose2D pos(position);\par
00049     pos.minus(center);\par
00050 \par
00051     pos.rotateByAngle(phi);\par
00052     pos.plus(Pose2D(x_translation_two, y_translation_two));\par
00053     {\cf19 return} pos;\par
00054 \}\par
00055 \par
00056 std::vector<Pose2D> Hole::getSuggestedNodePlacements() \{\par
00057     {\cf20 // the nodes that we will generate will be around the hole, One hole length * 1.5 45 degrees offset to each corner from the center of the hole}\par
00058     std::vector<Pose2D> toReturn;\par
00059 \par
00060     {\cf19 if} (this->foundHole) \{\par
00061     Pose2D center(this->cornerOne);\par
00062     center.setHeading(center.angleTo(this->cornerTwo));\par
00063     Pose2D temp(center);\par
00064     {\cf18 double} magnitude = HOLE_SIZE * 1.5;\par
00065         {\cf19 for} (uint8_t i = 0; i < 8; i++) \{\par
00066             Pose2D toAdd(temp);\par
00067             toAdd.translateByMagnitude(magnitude);\par
00068             toReturn.push_back(toAdd);\par
00069             temp.addAngle(M_PI / 4);\par
00070         \}\par
00071     \}\par
00072     {\cf19 else} \{\par
00073         {\cf19 for} (uint16_t i = 0; i < this->points->size(); i++) \{\par
00074         Pose2D suggested(this->points->at(i));\par
00075         suggested.addAngle(M_PI);\par
00076         suggested.translateByMagnitude(BOT_RADIUS);\par
00077         toReturn.push_back(suggested);\par
00078         \}\par
00079     \}\par
00080     {\cf19 return} toReturn;\par
00081     \}\par
00082 \par
00083     {\cf18 bool} Hole::isInSquare(Pose2D& position){\cf17  const }\{\par
00084     {\cf20 // std::cout << "starting position: " << position << std::endl;}\par
00085     {\cf20 // general idea: we use the operations in the object to translate objects for checks}\par
00086 \par
00087     Pose2D pos = copyDoOperation(position);\par
00088 \par
00089    {\cf20 // std::cout << "translated position: " << pos << std::endl;}\par
00090 \par
00091     {\cf19 if} (pos.getX() > 0 && pos.getX() < threshold && pos.getY() > 0 && pos.getY() < threshold) \{\par
00092         {\cf19 return} {\cf17 true};\par
00093     \}\par
00094     {\cf19 if} (pos.getX() - BOT_RADIUS > 0 && pos.getX() - BOT_RADIUS < threshold && pos.getY() > 0 && pos.getY() < threshold) \{\par
00095         {\cf19 return} {\cf17 true};\par
00096     \}\par
00097     {\cf19 if} (pos.getX() + BOT_RADIUS > 0 && pos.getX() + BOT_RADIUS < threshold && pos.getY() > 0 && pos.getY() < threshold) \{\par
00098         {\cf19 return} {\cf17 true};\par
00099     \}\par
00100     {\cf19 if} (pos.getX() > 0 && pos.getX() < threshold && pos.getY() + BOT_RADIUS > 0 && pos.getY() + BOT_RADIUS < threshold) \{\par
00101         {\cf19 return} {\cf17 true};\par
00102     \}\par
00103     {\cf19 if} (pos.getX() > 0 && pos.getX() < threshold && pos.getY() - BOT_RADIUS > 0 && pos.getY() - BOT_RADIUS < threshold) \{\par
00104         {\cf19 return} {\cf17 true};\par
00105     \}\par
00106     {\cf19 return} {\cf17 false};\par
00107 \par
00108 \}\par
00109 \par
00110 Hole::Hole({\cf18 double} X1, {\cf18 double} Y1, {\cf18 double} X2, {\cf18 double} Y2, {\cf18 double} holeSize) \{\par
00111     Pose2D o1(X1, Y1);\par
00112     Pose2D o2(X2, Y2);\par
00113     this->threshold = o1.distanceTo(o2) / sqrt(2);\par
00114     this->holeSize = holeSize;\par
00115     registerPointsToHole(o1, o2);\par
00116 \par
00117     this->points = std::make_unique<std::vector<Pose2D>>();\par
00118     this->pointHoles = std::make_unique<std::vector<Hole>>();\par
00119 \}\par
00120 \par
00121 Hole::Hole() \{\par
00122     this->holeSize = HOLE_SIZE;\par
00123     this->threshold = HOLE_SIZE;\par
00124     this->foundHole = {\cf17 false};\par
00125     this->points = std::make_unique<std::vector<Pose2D>>();\par
00126     this->pointHoles = std::make_unique<std::vector<Hole>>();\par
00127 \}\par
00128 \par
00129 Hole::Hole({\cf17 const} Pose2D& initialPoint, {\cf18 double} holeSize) \{\par
00130     this->foundHole = {\cf17 false};\par
00131     this->points = std::make_unique<std::vector<Pose2D>>();\par
00132     this->points->push_back(initialPoint);\par
00133     this->pointHoles = std::make_unique<std::vector<Hole>>();\par
00134     this->holeSize = holeSize;\par
00135     this->threshold = holeSize;\par
00136 \}\par
00137 \par
00138 {\cf18 bool} Hole::pointCouldBeMemberOfHole({\cf17 const} Pose2D& measurment) \{\par
00139     {\cf19 for} ({\cf17 const} {\cf17 auto}& point : *this->points) \{\par
00140         {\cf19 if} (point.distanceTo(measurment) > holeSize * std::sqrt(2)) \{\par
00141             {\cf19 return} {\cf17 false};\par
00142         \}\par
00143     \}\par
00144     {\cf19 return} {\cf17 true};\par
00145 \}\par
00146 \par
00147 Hole::Hole({\cf17 const} Hole& hole) \{\par
00148     this->cornerOne = hole.cornerOne;\par
00149     this->cornerTwo = hole.cornerTwo;\par
00150     this->foundHole = hole.foundHole;\par
00151     this->phi = hole.phi;\par
00152     this->threshold = hole.threshold;\par
00153     this->x_translation_one = hole.x_translation_one;\par
00154     this->y_translation_one = hole.y_translation_one;\par
00155     this->x_translation_two = hole.x_translation_two;\par
00156     this->y_translation_two = hole.y_translation_two;\par
00157     this->holeSize = hole.holeSize;\par
00158 \par
00159     this->points = std::make_unique<std::vector<Pose2D>>();\par
00160     {\cf19 for} (uint16_t i = 0; i < hole.points->size(); i++) \{\par
00161         this->points->push_back(hole.points->data()[i]);\par
00162     \}\par
00163     this->pointHoles = std::make_unique<std::vector<Hole>>();\par
00164     {\cf19 for} (uint16_t i = 0; i < hole.pointHoles->size(); i++) \{\par
00165         this->pointHoles->push_back(hole.pointHoles->data()[i]);\par
00166     \}\par
00167 \par
00168 \}\par
00169 \par
00170 {\cf18 void} Hole::addPoint({\cf17 const} Pose2D& position) \{\par
00171     this->points->push_back(position);\par
00172     {\cf20 //General flow:}\par
00173     {\cf19 if} (this->points->size() > 2) \{\par
00174         {\cf20 // should be 3 elements}\par
00175         {\cf20 // pick 2 with close headings}\par
00176 \par
00177         {\cf20 // find index of the pivot}\par
00178 \par
00179         Pose2D perpendicularPosition;\par
00180         Pose2D parallelOne;\par
00181         Pose2D parallelTwo;\par
00182 \par
00183         {\cf20 // positions one and two}\par
00184         {\cf19 if} (fabs(this->points->at(0).getHeading() - this->points->at(1).getHeading()) < M_PI / 2) \{\par
00185             {\cf20 // yay we have our parallel par of one and two}\par
00186             perpendicularPosition = this->points->at(2);\par
00187             parallelOne = this->points->at(0);\par
00188             parallelTwo = this->points->at(1);\par
00189         \}\par
00190         {\cf20 // check positions two and three}\par
00191         {\cf19 else} {\cf19 if} (fabs(this->points->at(1).getHeading() - this->points->at(2).getHeading()) < M_PI / 2) \{\par
00192             {\cf20 // yay we know our parallel pair are two and three}\par
00193             perpendicularPosition = this->points->at(0);\par
00194             parallelOne = this->points->at(1);\par
00195             parallelTwo = this->points->at(2);\par
00196         \}\par
00197 \par
00198         {\cf20 // check positions one and three}\par
00199         {\cf19 else} {\cf19 if} (fabs(this->points->at(0).getHeading() - this->points->at(2).getHeading()) < M_PI / 2) \{\par
00200             {\cf20 // we have our parallel pair of 1 and three}\par
00201             perpendicularPosition = this->points->at(1);\par
00202             parallelOne = this->points->at(0);\par
00203             parallelTwo = this->points->at(2);\par
00204         \}\par
00205 \par
00206         {\cf19 if} (parallelOne.getX() > parallelTwo.getX()) \{\par
00207             {\cf17 const} Pose2D temp = parallelOne;\par
00208             parallelOne = parallelTwo;\par
00209             parallelTwo = temp;\par
00210         \}\par
00211 \par
00212         {\cf20 // none of the angles are similiar so we know that we have three measurmenets from all different edges of the square}\par
00213         {\cf19 else} \{\par
00214             {\cf20 // get the two similiar angles when turned around}\par
00215             {\cf20 // pose 1 and 2 are out of phase}\par
00216             {\cf19 if} (fabs(this->points->at(0).getHeading() + this->points->at(1).getHeading()) < 0.1 || fabs(fabs(this->points->at(0).getHeading()) - fabs(this->points->at(1).getHeading())) < 0.1) \{\par
00217                 parallelOne = this->points->at(0);\par
00218                 parallelOne.translateByMagnitude(holeSize);\par
00219                 parallelTwo = this->points->at(1);\par
00220                 perpendicularPosition = this->points->at(2);\par
00221             \}\par
00222             {\cf20 // pose 2 and three are out of phase}\par
00223             {\cf19 else} {\cf19 if} (fabs(this->points->at(2).getHeading() + this->points->at(1).getHeading()) < 0.1 || fabs(fabs(this->points->at(2).getHeading()) - fabs(this->points->at(1).getHeading())) < 0.1) \{\par
00224                 parallelOne = this->points->at(2);\par
00225                 parallelOne.translateByMagnitude(holeSize);\par
00226                 parallelTwo = this->points->at(1);\par
00227                 perpendicularPosition = this->points->at(0);\par
00228             \}\par
00229             {\cf20 // pose 3 and 1 are out of phase}\par
00230             {\cf19 else} {\cf19 if} (fabs(this->points->at(0).getHeading() + this->points->at(2).getHeading()) < 0.1 || fabs(fabs(this->points->at(0).getHeading()) - fabs(this->points->at(2).getHeading())) < 0.1) \{\par
00231                 parallelOne = this->points->at(0);\par
00232                 parallelOne.translateByMagnitude(holeSize);\par
00233                 parallelTwo = this->points->at(2);\par
00234                 perpendicularPosition = this->points->at(1);\par
00235             \}\par
00236             {\cf19 else} \{\par
00237                 {\cf20 // i'm not sure how we got here and I' m just gonna clear the entire list}\par
00238                 this->points->clear();\par
00239             \}\par
00240 \par
00241         \}\par
00242 \par
00243         Pose2D cornerOne;\par
00244         Pose2D oppositeCorner;\par
00245 \par
00246         {\cf20 // now we have to make the cirtical points from the two parallel lines and the perpendicular line}\par
00247         {\cf18 double} dx = (parallelTwo.getX() - parallelOne.getX());\par
00248         {\cf18 double} dy = (parallelTwo.getY() - parallelOne.getY());\par
00249         {\cf19 if} (fabs(dx) < 0.01) \{\par
00250             {\cf20 // vertical line}\par
00251             {\cf18 double} xCornerOne = parallelOne.getX();\par
00252             {\cf18 double} yCornerOne = perpendicularPosition.getY();\par
00253             cornerOne = Pose2D(xCornerOne, yCornerOne);\par
00254             oppositeCorner = Pose2D(cornerOne);\par
00255             oppositeCorner.setHeading((cornerOne.angleTo(parallelOne) + cornerOne.angleTo(parallelTwo)) / 2);\par
00256             oppositeCorner.translateByMagnitude(holeSize * sqrt(2));\par
00257         \}\par
00258         {\cf20 // horizontal line}\par
00259         {\cf19 else} {\cf19 if} (fabs(dy) < 0.01) \{\par
00260             {\cf18 double} xCornerOne = perpendicularPosition.getX();\par
00261             {\cf18 double} yCornerOne = parallelOne.getY();\par
00262             cornerOne = Pose2D(xCornerOne, yCornerOne);\par
00263             oppositeCorner = Pose2D(cornerOne);\par
00264             oppositeCorner.setHeading((parallelOne.getX() + perpendicularPosition.getX()) / 2);\par
00265             oppositeCorner.translateByMagnitude(holeSize * sqrt(2));\par
00266         \}\par
00267         {\cf19 else} \{\par
00268             {\cf18 double} m1 = (parallelTwo.getY() - parallelOne.getY()) / dx;\par
00269             {\cf18 double} b1 = - m1 * parallelOne.getX() + parallelOne.getY();\par
00270             {\cf18 double} m2 = - 1 / m1;\par
00271             {\cf18 double} b2 = -m2 * perpendicularPosition.getX() + perpendicularPosition.getY();\par
00272 \par
00273             {\cf18 double} xIntersection = (1 / m1 + m1) / (b2 - b1);\par
00274             {\cf18 double} yIntersection = xIntersection * m1 + b1;\par
00275             cornerOne = Pose2D(xIntersection, yIntersection);\par
00276 \par
00277             {\cf20 // favorite very dumb method}\par
00278             {\cf18 double} angleToOther = (cornerOne.angleTo(parallelOne) + cornerOne.angleTo(perpendicularPosition)) / 2;\par
00279             oppositeCorner = Pose2D(cornerOne);\par
00280             oppositeCorner.setHeading(angleToOther);\par
00281             oppositeCorner.translateByMagnitude(holeSize * sqrt(2));\par
00282         \}\par
00283 \par
00284         this->cornerOne = cornerOne;\par
00285         this->cornerTwo = oppositeCorner;\par
00286         this->foundHole = {\cf17 true};\par
00287     \}\par
00288 \par
00289     {\cf19 if} (!foundHole) \{\par
00290         Pose2D cornerOneNew(position);\par
00291         cornerOneNew.rotateByAngle(M_PI / 4);\par
00292         cornerOneNew.translateByMagnitude(2);\par
00293         Pose2D cornerTwoNew(position);\par
00294         {\cf20 // an astute reader will notice that this is really stupid and that there is a relatively simple}\par
00295         {\cf20 // math to accomplish this goal in one operation}\par
00296         {\cf20 // however I am stupid}\par
00297         cornerTwoNew.rotateByAngle(-M_PI / 4);\par
00298         cornerTwoNew.translateByMagnitude(2);\par
00299         cornerTwoNew.rotateByAngle(M_PI / 2);\par
00300         cornerTwoNew.translateByMagnitude(4);\par
00301         Hole hole(cornerOneNew, cornerTwoNew, 4);\par
00302         this->pointHoles->push_back(hole);\par
00303     \}\par
00304 \}\par
00305 \par
00306 {\cf18 void} Hole::registerPointsToHole({\cf17 const} Pose2D& positionOne, {\cf17 const} Pose2D& positionTwo) \{\par
00307     {\cf20 // calculate the first translation}\par
00308     cornerOne = Pose2D(positionOne);\par
00309     cornerTwo = Pose2D(positionTwo);\par
00310     Pose2D D(positionOne);\par
00311     foundHole = {\cf17 true};\par
00312 \par
00313     {\cf20 // wrong should be center x and y}\par
00314     Pose2D center(positionOne);\par
00315     center.vecAdd(center.angleTo(positionTwo), center.distanceTo(positionTwo) / 2);\par
00316     x_translation_one = -center.getX();\par
00317     y_translation_one = -center.getY();\par
00318 \par
00319     {\cf18 double} phi;\par
00320     D.plus(Pose2D(x_translation_one, y_translation_one));\par
00321     {\cf19 switch} (D.getQuadrant()) \{\par
00322         {\cf19 case} 0:\par
00323             {\cf19 if} (fabs(D.getX()) < 0.01) \{\par
00324                 {\cf20 // on y axis}\par
00325                 {\cf19 if} (D.getY() < 0) \{\par
00326                     phi = - M_PI / 3; {\cf20 // just a nudge}\par
00327                 \}\par
00328                 {\cf19 else} \{\par
00329                     phi = M_PI / 4 * 3;\par
00330                 \}\par
00331             \}\par
00332             {\cf19 else} \{\par
00333                 {\cf20 // on x axis}\par
00334                 {\cf19 if} (D.getX() > 0) \{\par
00335                     phi = -M_PI / 4 * 3;\par
00336                 \}\par
00337                 {\cf19 else} \{\par
00338                     phi = M_PI / 3;\par
00339                 \}\par
00340             \}\par
00341             {\cf19 break};\par
00342         {\cf19 case} 1:\par
00343             phi = M_PI;\par
00344         {\cf19 break};\par
00345         {\cf19 case} 2:\par
00346             phi = M_PI / 2;\par
00347         {\cf19 break};\par
00348         {\cf19 case} 4:\par
00349             phi = -M_PI / 2;\par
00350         {\cf19 break};\par
00351         {\cf19 default}:\par
00352             phi = 0;\par
00353         {\cf19 break};\par
00354     \}\par
00355 \par
00356     D.rotateByAngle(phi);\par
00357 \par
00358     {\cf18 double} newAngle = M_PI / 4 - atan2(-D.getY(), -D.getX()); {\cf20 // see desmos graph}\par
00359     D.rotateByAngle(newAngle);\par
00360     phi = newAngle;\par
00361     this->phi = phi;\par
00362     {\cf20 // calculate position one into}\par
00363     x_translation_two = -D.getX();\par
00364     y_translation_two = -D.getY();\par
00365 \par
00366     threshold = cornerOne.distanceTo(cornerTwo) / sqrt(2);\par
00367 \par
00368     {\cf20 /*std::cout << "x translation: " << x_translation_one << std::endl << "y translation: " << y_translation_one << std::endl}\par
00369 {\cf20     << "angleTurn: " << phi << std::endl << "x translation 2: " << x_translation_two << std::endl << "y_translation: " << y_translation_two << std::endl}\par
00370 {\cf20     << "threshold: " << threshold << std::endl;*/}\par
00371 \}\par
00372 \par
00373 std::ostream &operator<<(std::ostream &os, {\cf17 const} Hole &hole) \{\par
00374     os << {\cf22 "cornerOne: "} << hole.cornerOne << {\cf22 " cornerTwo: "} << hole.cornerTwo << {\cf22 " threshold: "} << hole.threshold << {\cf22 " phi: "} << hole.phi\par
00375     << {\cf22 " x_translation_one: "} << hole.x_translation_one << {\cf22 " y_translation_one: "} << hole.y_translation_one\par
00376        << {\cf22 " x_translation_two: "} << hole.x_translation_two << {\cf22 " y_translation_two: "} << hole.y_translation_two\par
00377        << {\cf22 " foundHole: "} << hole.foundHole << {\cf22 " points: "} << hole.points;\par
00378     {\cf19 return} os;\par
00379 \}\par
00380 \par
00381 {\cf18 void} Hole::offset({\cf17 const} Pose2D& offset) \{\par
00382     {\cf19 if} (foundHole) \{\par
00383         this->cornerOne.plus(offset);\par
00384         this->cornerTwo.plus(offset);\par
00385         registerPointsToHole(cornerOne, cornerTwo);\par
00386     \}\par
00387     {\cf19 for} (uint16_t i = 0; i < this->points->size(); i++) \{\par
00388         this->points->at(i).plus(offset);\par
00389         this->pointHoles->at(i).offset(offset);\par
00390     \}\par
00391 \}\par
00392 \par
00393 {\cf18 bool} Hole::lineIntersectsHole({\cf17 const} Pose2D& posOne, {\cf17 const} Pose2D& posTwo){\cf17  const }\{\par
00394     {\cf19 if} (foundHole) \{\par
00395         Pose2D positionOne;\par
00396         Pose2D positionTwo;\par
00397         {\cf19 if} (posOne.getX() < posTwo.getX()) \{\par
00398             positionOne = copyDoOperation(posOne);\par
00399             positionTwo = copyDoOperation(posTwo);\par
00400         \} {\cf19 else} \{\par
00401             positionOne = copyDoOperation(posTwo);\par
00402             positionTwo = copyDoOperation(posOne);\par
00403         \}\par
00404 \par
00405         {\cf20 // if the line between them, at any point falls between 0 and threshold}\par
00406         {\cf20 // annoyingly I think this means that we need to do real math (ew)}\par
00407         {\cf19 if} (fabs(positionOne.getX() - positionTwo.getX()) < 0.05) \{\par
00408             {\cf20 // we have a vertical line}\par
00409             {\cf20 // if the vertical line starts below 0 and ends after threshold and X is between 0 and threshold then it intersects}\par
00410             {\cf19 return} (((positionOne.getX() > 0 && positionOne.getX() < threshold) ||\par
00411                      (positionTwo.getX() > 0 && positionTwo.getX() < threshold)) &&\par
00412                     fmax(positionOne.getY(), positionTwo.getY()) > threshold &&\par
00413                     fmin(positionOne.getY(), positionTwo.getY()) < 0);\par
00414 \par
00415         \}\par
00416         {\cf19 if} (fabs(positionOne.getY() - positionTwo.getY()) < 0.05) \{\par
00417             {\cf20 // we have a horizontal line}\par
00418             {\cf19 return} (((positionOne.getY() > 0 && positionOne.getY() < threshold) ||\par
00419                      (positionTwo.getY() > 0 && positionTwo.getY() < threshold)) &&\par
00420                     fmax(positionOne.getX(), positionTwo.getX()) > threshold &&\par
00421                     fmin(positionOne.getX(), positionTwo.getX()) < 0);\par
00422         \}\par
00423 \par
00424         {\cf20 // now we gotta make a line, which we can guranteed will exist without a slope of 0}\par
00425         {\cf18 double} m = (positionTwo.getY() - positionOne.getY()) / (positionTwo.getX() - positionOne.getX());\par
00426         {\cf18 double} b = positionOne.getY() - (positionOne.getX() * m);\par
00427 \par
00428         {\cf20 // now that we know the equation of the line we can determine if it intersects the x axis, y axis, or y = threshold or x = threshold}\par
00429         {\cf20 // yayyyy finding 0's of a function}\par
00430         {\cf18 double} y2Check = m * positionOne.getX() + b;\par
00431         {\cf19 if} ((b < threshold && b > 0) || (y2Check < threshold && y2Check > 0)) \{\par
00432             {\cf19 return} {\cf17 true}; {\cf20 // we intersect with the x axis}\par
00433         \}\par
00434         {\cf18 double} xValueAtYIsZero = (-b / m);\par
00435         {\cf18 double} xValueATYIsThreshold = (threshold - b) / m;\par
00436         {\cf19 return} (xValueAtYIsZero > 0 && xValueAtYIsZero < threshold) ||\par
00437                (xValueATYIsThreshold > 0 && xValueATYIsThreshold < threshold);\par
00438     \}\par
00439     {\cf19 else} \{\par
00440         {\cf19 for} (uint16_t i = 0; i < this->pointHoles->size(); i++) \{\par
00441             {\cf19 if} (this->pointHoles->at(i).lineIntersectsHole(posOne, posTwo)) \{\par
00442                 {\cf19 return} {\cf17 true};\par
00443             \}\par
00444         \}\par
00445     \}\par
00446     {\cf19 return} {\cf17 false};\par
00447 \}\par
00448 \par
00449 Hole::Hole({\cf18 double} x1, {\cf18 double} y1, {\cf18 double} x2, {\cf18 double} y2) \{\par
00450     this->cornerOne = Pose2D(x1, y1);\par
00451     this->cornerTwo = Pose2D(x2, y2);\par
00452     this->points = std::make_unique<std::vector<Pose2D>>();\par
00453     this->pointHoles = std::make_unique<std::vector<Hole>>();\par
00454     this->holeSize = cornerOne.distanceTo(cornerTwo) / sqrt(2);\par
00455     registerPointsToHole(cornerOne, cornerTwo);\par
00456 \}\par
00457 \par
00458 std::vector<Hole> Hole::getSubHolesCopy(){\cf17  const }\{\par
00459     std::vector<Hole> toReturn;\par
00460     {\cf19 for} (uint16_t i = 0; i < this->pointHoles->size(); i++) \{\par
00461         toReturn.push_back(this->pointHoles->at(i));\par
00462     \}\par
00463     {\cf19 return} toReturn;\par
00464 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/calebk/Documents/coding/RoombaController/src/Hole.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v /home/calebk/Documents/coding/RoombaController/src/Hole.hpp}
{\xe \v /home/calebk/Documents/coding/RoombaController/src/Hole.hpp}
{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "vector"}\par
{\f2 #include <memory>}\par
{\f2 #include "Pose2D.hpp"}\par
{\f2 #include <cmath>}\par
{\f2 #include <ostream>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Hole}}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HOLE_SIZE}\~ 69.06\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v HOLE_SIZE\:Hole.hpp}
{\xe \v Hole.hpp\:HOLE_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HOLE_SIZE\~ 69.06}}
\par
{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Made by Caleb Kugel on 11/15/2024 \par
}{
Definition at line {\b 14} of file {\b Hole.hpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Hole.hpp\par \pard\plain 
{\tc\tcl2 \v /home/calebk/Documents/coding/RoombaController/src/Hole.hpp}
{\xe \v /home/calebk/Documents/coding/RoombaController/src/Hole.hpp}
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00005 {\cf21 #ifndef HOLE_H}\par
00006 {\cf21 #define HOLE_H}\par
00007 \par
00008 {\cf21 #include "vector"}\par
00009 {\cf21 #include <memory>}\par
00010 {\cf21 #include "Pose2D.hpp"}\par
00011 {\cf21 #include <cmath>}\par
00012 {\cf21 #include <ostream>}\par
00013 \par
00014 {\cf21 #define HOLE_SIZE 69.06 }{\cf20 // centimeters}\par
00015 \par
00020 {\cf17 class }Hole \{\par
00021     {\cf17 private}:\par
00022     Pose2D cornerOne;\par
00023     Pose2D cornerTwo;\par
00024     {\cf18 double} threshold = -1;\par
00025     {\cf18 double} phi = -1;\par
00026     {\cf18 double} x_translation_one = -1;\par
00027     {\cf18 double} y_translation_one = -1;\par
00028     {\cf18 double} x_translation_two = -1;\par
00029     {\cf18 double} y_translation_two = -1;\par
00030     {\cf18 double} holeSize = -1;\par
00031 \par
00032     {\cf18 bool} foundHole = {\cf17 false};\par
00033 \par
00034     std::unique_ptr<std::vector<Pose2D>> points;\par
00035     std::unique_ptr<std::vector<Hole>> pointHoles;\par
00036     {\cf17 public}:\par
00037     \par
00045     Hole({\cf18 double} X1, {\cf18 double} Y1, {\cf18 double} X2, {\cf18 double} Y2, {\cf18 double} holeSize);\par
00046 \par
00050     Hole({\cf17 const} Pose2D& positionOne, {\cf17 const} Pose2D& positionTwo, {\cf18 bool} foundHole, {\cf17 const} std::vector<Pose2D>& points, {\cf18 double} holeSize);\par
00051 \par
00059     Hole({\cf18 double} x1, {\cf18 double} y1, {\cf18 double} x2, {\cf18 double} y2);\par
00060 \par
00064     Hole({\cf17 const} Pose2D& positionOne, {\cf17 const} Pose2D& positionTwo, {\cf18 double} holeSize);\par
00065 \par
00071     std::vector<Pose2D> getSuggestedNodePlacements();\par
00072 \par
00078     {\cf18 void} registerPointsToHole({\cf17 const} Pose2D& positionOne, {\cf17 const} Pose2D& positionTwo);\par
00079 \par
00086     {\cf17 friend} std::ostream &operator<<(std::ostream &os, {\cf17 const} Hole &hole);\par
00087 \par
00093     [[nodiscard]] Pose2D copyDoOperation({\cf17 const} Pose2D& position) {\cf17 const};\par
00094     \par
00098     Pose2D getOneSquareCorner();\par
00099 \par
00103     Pose2D getSecondSquareCorner();\par
00104 \par
00109     {\cf18 bool} pointCouldBeMemberOfHole({\cf17 const} Pose2D& measurment);\par
00110 \par
00115     {\cf18 bool} isFoundHole(){\cf17  const }\{{\cf19 return} foundHole;\}\par
00116 \par
00121     [[nodiscard]] std::vector<Hole> getSubHolesCopy() {\cf17 const};\par
00122 \par
00126     Hole();\par
00127 \par
00131     Hole({\cf17 const} Hole& hole);\par
00132 \par
00137     {\cf17 explicit} Hole({\cf17 const} Pose2D& initialPoint, {\cf18 double} holeSize);\par
00138 \par
00144     {\cf18 void} addPoint({\cf17 const} Pose2D& position);\par
00145 \par
00151     {\cf18 bool} isInSquare(Pose2D& position) {\cf17 const};\par
00152 \par
00157     {\cf18 void} offset({\cf17 const} Pose2D& offset);\par
00158 \par
00164      {\cf18 bool} lineIntersectsHole({\cf17 const} Pose2D& posOne, {\cf17 const} Pose2D& posTwo) {\cf17 const};\par
00165 \};\par
00166 \par
00167 {\cf21 #endif }{\cf20 // HOLE_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/calebk/Documents/coding/RoombaController/src/HoleManager.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /home/calebk/Documents/coding/RoombaController/src/HoleManager.cpp}
{\xe \v /home/calebk/Documents/coding/RoombaController/src/HoleManager.cpp}
{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <iostream>}\par
{\f2 #include "HoleManager.hpp"}\par
{\f2 #include "Field.hpp"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
HoleManager.cpp\par \pard\plain 
{\tc\tcl2 \v /home/calebk/Documents/coding/RoombaController/src/HoleManager.cpp}
{\xe \v /home/calebk/Documents/coding/RoombaController/src/HoleManager.cpp}
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00005 {\cf21 #include <iostream>}\par
00006 {\cf21 #include "HoleManager.hpp"}\par
00007 {\cf21 #include "Field.hpp"}\par
00008 \par
00009 HoleManager::HoleManager() \{\par
00010     holes = std::make_unique<std::vector<Hole>>();\par
00011     holeMeasurements = std::make_unique<std::vector<Pose2D>>();\par
00012 \}\par
00013 \par
00014 {\cf18 void} HoleManager::addHole({\cf17 const} Pose2D& cornerOne, {\cf17 const} Pose2D& cornerTwo) \{\par
00015     {\cf18 double} size = cornerOne.distanceTo(cornerTwo) / sqrt(2);\par
00016     this->holes->push_back(Hole(cornerOne, cornerTwo, size));\par
00017 \}\par
00018 \par
00019 {\cf18 void} HoleManager::addHole({\cf17 const} Hole& hole) \{\par
00020     this->holes->push_back(hole);\par
00021 \}\par
00022 \par
00023 Hole HoleManager::getHole(uint8_t index) \{\par
00024     {\cf19 if} (index > holes->size()) \{\par
00025         {\cf19 return} \{NAN, NAN, NAN, NAN, NAN\};\par
00026     \}\par
00027     {\cf19 else} \{\par
00028         {\cf19 return} holes->data()[index];\par
00029     \}\par
00030 \}\par
00031 \par
00032 std::vector<Hole> HoleManager::getHoles() \{\par
00033     std::vector<Hole> toCpy;\par
00034     {\cf19 for} (uint8_t i = 0; i < holes->size(); i++) \{\par
00035         toCpy.push_back(holes->data()[i]); {\cf20 // Unsafe lol}\par
00036     \}\par
00037     {\cf19 return} toCpy;\par
00038 \}\par
00039 \par
00040 {\cf18 void} HoleManager::addPoint({\cf17 const} Pose2D& position) \{\par
00041     {\cf18 bool} foundMatch = {\cf17 false};\par
00042    this->holeMeasurements->push_back(position); \par
00043     {\cf19 for} (uint16_t i = 0; i < this->holes->size(); i++) \{\par
00044         {\cf19 if} (this->holes->data()[i].pointCouldBeMemberOfHole(position)) \{\par
00045             this->holes->data()[i].addPoint(position);\par
00046             foundMatch = {\cf17 true};\par
00047             {\cf19 break};\par
00048         \}\par
00049     \}\par
00050     {\cf19 if} (!foundMatch) \{\par
00051         this->holes->push_back(Hole(position, HOLE_SIZE));\par
00052     \}\par
00053 \}\par
00054 \par
00055 {\cf20 // deiscretization step}\par
00056 {\cf18 bool} HoleManager::nodeCollides(Pose2D position) \{\par
00057 \par
00058     {\cf20 // shoot out a small line from the position in the dircection of the heading}\par
00059     {\cf20 /*}\par
00060 {\cf20     for (uint16_t i = 0; i < this->holeMeasurements->size(); i++) \{}\par
00061 {\cf20         Pose2D initial = this->holeMeasurements->at(i);}\par
00062 {\cf20         Pose2D pose2(this->holeMeasurements->at(i)); // should copy}\par
00063 {\cf20         pose2.translateByMagnitude(HOLE_SIZE * 0.5);}\par
00064 {\cf20         if (position.isOnLine(initial, pose2)) \{}\par
00065 {\cf20             return true;}\par
00066 {\cf20         \}}\par
00067 {\cf20     \}}\par
00068 {\cf20      */}\par
00069 \par
00070     {\cf19 for} (uint8_t i = 0; i < this->holes->size(); i++) \{\par
00071         {\cf20 //std::cout << this->holes->at(i) << std::endl;}\par
00072         {\cf19 if} (this->holes->at(i).isInSquare(position)) \{\par
00073             {\cf20 // std::cout << "failed for: " << position.getX() << ", " << position.getY() << std::endl;}\par
00074             {\cf19 return} {\cf17 true};\par
00075         \}\par
00076     \}\par
00077     {\cf19 return} {\cf17 false};\par
00078 \}\par
00079 \par
00080 std::vector<Pose2D> HoleManager::getSuggestedNodePlacements() \{\par
00081     {\cf20 // for every hole return a few points around the square}\par
00082     \par
00083     std::vector<Pose2D> toReturn;\par
00084     {\cf19 for} (uint16_t i = 0; i < this->holes->size(); i++) \{\par
00085     std::vector<Pose2D> placements = this->holes->at(i).getSuggestedNodePlacements();\par
00086     {\cf19 for} (uint16_t j = 0; j < placements.size(); j++) \{\par
00087         toReturn.push_back(placements.at(j));\par
00088     \}\par
00089     \} \par
00090     {\cf19 return} toReturn;\par
00091 \}\par
00092 \par
00093 {\cf20 // weighting step}\par
00094 {\cf18 bool} HoleManager::lineIntersectsAnyHoleMeasurement({\cf17 const} Pose2D& positionOne, {\cf17 const} Pose2D& positionTwo) \{\par
00095     {\cf20 // we have a pose of each measurement}\par
00096     {\cf20 // have to make the rectangle and the expected line}\par
00097 \par
00098     {\cf20 /*}\par
00099 {\cf20     for (uint16_t i = 0; i < this->holeMeasurements->size(); i++) \{}\par
00100 {\cf20     // for every point make the rectangle}\par
00101 {\cf20     Rectangle rect = makeRectangleFromLine(positionOne, positionTwo, MEASUREMENT_WIDTH);    }\par
00102 {\cf20         if (lineIntersectsRectangle(positionOne.getX(), positionOne.getY(), positionTwo.getX(), positionTwo.getY(), rect.r1.getX(), rect.r1.getY(), rect.r2.getX(), rect.r2.getY(), rect.r3.getX(), rect.r3.getY(), rect.r4.getX(), rect.r4.getY())) \{}\par
00103 {\cf20             return true;}\par
00104 {\cf20         \}}\par
00105 {\cf20     \}}\par
00106 {\cf20     */}\par
00107 \par
00108     {\cf19 for} (uint16_t i = 0; i < this->holes->size(); i++) \{\par
00109         {\cf19 if} (this->holes->at(i).lineIntersectsHole(positionOne, positionTwo)) \{\par
00110             {\cf19 return} {\cf17 true};\par
00111         \}\par
00112     \}\par
00113 \par
00114     {\cf19 return} {\cf17 false};\par
00115 \}\par
00116 \par
00117 {\cf18 void} HoleManager::offsetAll({\cf17 const} Pose2D& offset){\cf17  const }\{\par
00118     {\cf19 for} (uint16_t i = 0; i < this->holes->size(); i++) \{\par
00119         this->holes->at(i).offset(offset);\par
00120     \}\par
00121     {\cf19 for} (uint16_t i = 0; i < this->holeMeasurements->size(); i++) \{\par
00122         this->holeMeasurements->at(i).plus(offset);\par
00123     \}\par
00124 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/calebk/Documents/coding/RoombaController/src/HoleManager.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v /home/calebk/Documents/coding/RoombaController/src/HoleManager.hpp}
{\xe \v /home/calebk/Documents/coding/RoombaController/src/HoleManager.hpp}
{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Hole.hpp"}\par
{\f2 #include "util.hpp"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b HoleManager}}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b sideLength}\~ 0.6096\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MEASUREMENT_WIDTH}\~ 0.05\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v MEASUREMENT_WIDTH\:HoleManager.hpp}
{\xe \v HoleManager.hpp\:MEASUREMENT_WIDTH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MEASUREMENT_WIDTH\~ 0.05}}
\par
{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 12} of file {\b HoleManager.hpp}.}\par
}
{\xe \v sideLength\:HoleManager.hpp}
{\xe \v HoleManager.hpp\:sideLength}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define sideLength\~ 0.6096}}
\par
{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Created by Caleb Kugel 11/15/2024 \par
}{
Definition at line {\b 11} of file {\b HoleManager.hpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
HoleManager.hpp\par \pard\plain 
{\tc\tcl2 \v /home/calebk/Documents/coding/RoombaController/src/HoleManager.hpp}
{\xe \v /home/calebk/Documents/coding/RoombaController/src/HoleManager.hpp}
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00005 {\cf21 #ifndef HOLE_MANAGER_H}\par
00006 {\cf21 #define HOLE_MANAGER_H}\par
00007 \par
00008 {\cf21 #include "Hole.hpp"}\par
00009 {\cf21 #include "util.hpp"}\par
00010 \par
00011 {\cf21 #define sideLength 0.6096 }{\cf20 // 2 by 2 squares in feet. meters}\par
00012 {\cf21 #define MEASUREMENT_WIDTH 0.05 }{\cf20 // meters}\par
00013 \par
00018 {\cf17 class }HoleManager \{\par
00019     {\cf17 private}:\par
00023     std::unique_ptr<std::vector<Hole>> holes;\par
00024 \par
00028     std::unique_ptr<std::vector<Pose2D>> holeMeasurements;\par
00029     {\cf17 public}:\par
00033         HoleManager();\par
00034 \par
00039         {\cf18 void} addPoint({\cf17 const} Pose2D& position);\par
00040 \par
00046         Hole getHole(uint8_t index);\par
00047 \par
00052         {\cf18 void} addHole({\cf17 const} Hole& hole);\par
00053 \par
00059         {\cf18 void} addHole({\cf17 const} Pose2D& cornerOne, {\cf17 const} Pose2D& cornerTwo);\par
00060 \par
00064         std::vector<Hole> getHoles();\par
00065 \par
00069         std::vector<Pose2D> getPointsOnHoles();\par
00070 \par
00074         std::vector<Pose2D> getSuggestedNodePlacements();\par
00075 \par
00081         {\cf18 bool} nodeCollides(Pose2D position);\par
00082 \par
00086         {\cf18 bool} lineIntersectsAnyHoleMeasurement({\cf17 const} Pose2D& positionOne, {\cf17 const} Pose2D& positionTwo);\par
00087 \par
00091         {\cf18 void} offsetAll({\cf17 const} Pose2D& offset) {\cf17 const};\par
00092 \par
00093 \};\par
00094 \par
00095 \par
00096 {\cf21 #endif }{\cf20 //HOLE_MANAGER_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/calebk/Documents/coding/RoombaController/src/main.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /home/calebk/Documents/coding/RoombaController/src/main.cpp}
{\xe \v /home/calebk/Documents/coding/RoombaController/src/main.cpp}
{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../include/imgui/imgui.h"}\par
{\f2 #include "../include/imgui/backends/imgui_impl_glfw.h"}\par
{\f2 #include "../include/imgui/backends/imgui_impl_opengl3.h"}\par
{\f2 #include <GLFW/glfw3.h>}\par
{\f2 #include "Pose2D.hpp"}\par
{\f2 #include "Node.hpp"}\par
{\f2 #include "Pillar.hpp"}\par
{\f2 #include "Hole.hpp"}\par
{\f2 #include "Field.hpp"}\par
{\f2 #include <vector>}\par
{\f2 #include <netinet/in.h>}\par
{\f2 #include <chrono>}\par
{\f2 #include <sys/socket.h>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include <arpa/inet.h>}\par
{\f2 #include <fstream>}\par
{\f2 #include <iostream>}\par
{\f2 #include <thread>}\par
{\f2 #include <queue>}\par
{\f2 #include <condition_variable>}\par
{\f2 #include <atomic>}\par
{\f2 #include <sstream>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Move}}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BOT_CONNECT}\~ 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADDRESS}\~ "127.0.0.1"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PORT}\~ 65432\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b MovementType} \{ {\b MOVE_FORWARD}
, {\b MOVE_BACKWARDS}
, {\b MOVE_FORWARD_SMART}
, {\b TURN_TO_ANGLE}
, {\b SCAN}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::atomic< bool > {\b stopClient} (false)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addToQueue} (const std::string &message)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b sendAngleToQueue} (int16_t angle)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b sendDistanceToQueue} (uint16_t distance)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b pathToRoutine} (std::vector< {\b Pose2D} > path, std::vector< {\b Move} > &routine)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b parsePathIntoRoutine} (const std::vector< {\b Pose2D} > &path)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b readAndLog} (int socket, std::mutex &fieldMutex, {\b Field} &field, std::vector< {\b Pose2D} > &path)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b connectTCP} ({\b Field} &field, std::mutex &fieldMutex, std::vector< {\b Pose2D} > &path)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setupImGui} (GLFWwindow *window)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b DrawCircle} (ImDrawList *drawList, const ImVec2 &center, float radius, ImU32 color)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Pose2D} {\b ScreenToCoords} (ImVec2 coords, ImVec2 offset, ImVec2 scaling)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ImVec2 {\b coordsToScreen} (ImVec2 offset, ImVec2 scaling, double x, double y)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ImVec2 {\b coordsToScreen} (ImVec2 offset, ImVec2 scaling, const {\b Pose2D} &position)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ShowPillarOnWindow} (ImDrawList *drawList, {\b Pillar} pillar, ImU32 color, ImVec2 offset, ImVec2 scaling)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b drawBotPose} (ImDrawList *drawList, const {\b Pose2D} &botPose, ImVec2 offset, ImVec2 scaling)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b drawRectangle} (ImDrawList *drawList, ImVec2 offset, ImVec2 scaling, const {\b Pose2D} &p1, const {\b Pose2D} &p2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ShowFieldWindow} (std::mutex *pillarsMutex, std::vector< {\b Pose2D} > &path, {\b Field} &field, std::atomic< bool > &showNodes, std::atomic< bool > &showEdges)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::queue< std::string > {\b sendQueue}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::mutex {\b queueMutex}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::condition_variable {\b sendCondition}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v ADDRESS\:main.cpp}
{\xe \v main.cpp\:ADDRESS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADDRESS\~ "127.0.0.1"}}
\par
{\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 29} of file {\b main.cpp}.}\par
}
{\xe \v BOT_CONNECT\:main.cpp}
{\xe \v main.cpp\:BOT_CONNECT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BOT_CONNECT\~ 0}}
\par
{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 24} of file {\b main.cpp}.}\par
}
{\xe \v PORT\:main.cpp}
{\xe \v main.cpp\:PORT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PORT\~ 65432}}
\par
{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 30} of file {\b main.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v MovementType\:main.cpp}
{\xe \v main.cpp\:MovementType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b MovementType}}}
\par
{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v MOVE_FORWARD\:main.cpp}
{\xe \v main.cpp\:MOVE_FORWARD}
{\qr MOVE_FORWARD{\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
\cell }{\cell }{\row }
{\xe \v MOVE_BACKWARDS\:main.cpp}
{\xe \v main.cpp\:MOVE_BACKWARDS}
{\qr MOVE_BACKWARDS{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
\cell }{\cell }{\row }
{\xe \v MOVE_FORWARD_SMART\:main.cpp}
{\xe \v main.cpp\:MOVE_FORWARD_SMART}
{\qr MOVE_FORWARD_SMART{\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
\cell }{\cell }{\row }
{\xe \v TURN_TO_ANGLE\:main.cpp}
{\xe \v main.cpp\:TURN_TO_ANGLE}
{\qr TURN_TO_ANGLE{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
\cell }{\cell }{\row }
{\xe \v SCAN\:main.cpp}
{\xe \v main.cpp\:SCAN}
{\qr SCAN{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 33} of file {\b main.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v addToQueue\:main.cpp}
{\xe \v main.cpp\:addToQueue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void addToQueue (const std::string &  {\i message})}}
\par
{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a given string to the thread safe queue, accessed with mutexes {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i message} \cell }{the message to add \cell }
{\row }
}
}{
Definition at line {\b 56} of file {\b main.cpp}.}\par
}
{\xe \v connectTCP\:main.cpp}
{\xe \v main.cpp\:connectTCP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void connectTCP ({\b Field} &  {\i field}, std::mutex &  {\i fieldMutex}, std::vector< {\b Pose2D} > &  {\i path})}}
\par
{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
connect to Roomba TCP server or the mock server depending on the configuration {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i field} \cell }{reference to the field object \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fieldMutex} \cell }{the mutex for the field \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i path} \cell }{reference to a generated path \cell }
{\row }
}
}{
Definition at line {\b 291} of file {\b main.cpp}.}\par
}
{\xe \v coordsToScreen\:main.cpp}
{\xe \v main.cpp\:coordsToScreen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ImVec2 coordsToScreen (ImVec2  {\i offset}, ImVec2  {\i scaling}, const {\b Pose2D} &  {\i position})}}
\par
{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Computes screen coordinates from {\b Field} coordinates {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i offset} \cell }{the offset the window measuring on is at \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i scaling} \cell }{the amount to scale by \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i position} \cell }{the position be transformed \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
the new screen coordinates \par
}}}{
Definition at line {\b 396} of file {\b main.cpp}.}\par
}
{\xe \v coordsToScreen\:main.cpp}
{\xe \v main.cpp\:coordsToScreen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ImVec2 coordsToScreen (ImVec2  {\i offset}, ImVec2  {\i scaling}, double  {\i x}, double  {\i y})}}
\par
{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Computes screen coordinates from {\b Field} coordinates {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i offset} \cell }{the offset the window measuring on is at \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i scaling} \cell }{the amount to scale by \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i x} \cell }{the x component of the pose 2d \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i y} \cell }{the y component of the pose 2d \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
the new screen coordinates \par
}}}{
Definition at line {\b 383} of file {\b main.cpp}.}\par
}
{\xe \v drawBotPose\:main.cpp}
{\xe \v main.cpp\:drawBotPose}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void drawBotPose (ImDrawList *  {\i drawList}, const {\b Pose2D} &  {\i botPose}, ImVec2  {\i offset}, ImVec2  {\i scaling})}}
\par
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Draws a triangle on the bot position facing in the direction that the bot is. The color of the triangle will be lime green.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i drawList} \cell }{the draw list for the window \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i botPose} \cell }{the position of the bot \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i offset} \cell }{the offset of the screen for cartesian coordinates \cell }
{\row }
}
}{
Definition at line {\b 423} of file {\b main.cpp}.}\par
}
{\xe \v DrawCircle\:main.cpp}
{\xe \v main.cpp\:DrawCircle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DrawCircle (ImDrawList *  {\i drawList}, const ImVec2 &  {\i center}, float  {\i radius}, ImU32  {\i color})}}
\par
{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Draw a circle on the window {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i drawList} \cell }{the drawlist for a given window \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i center} \cell }{the center position of the circle \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i radius} \cell }{the radus of the circle \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i color} \cell }{the color of the circle on the screen \cell }
{\row }
}
}{
Definition at line {\b 357} of file {\b main.cpp}.}\par
}
{\xe \v drawRectangle\:main.cpp}
{\xe \v main.cpp\:drawRectangle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void drawRectangle (ImDrawList *  {\i drawList}, ImVec2  {\i offset}, ImVec2  {\i scaling}, const {\b Pose2D} &  {\i p1}, const {\b Pose2D} &  {\i p2})}}
\par
{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Draw a rectangle on the field given by the critical points p1 and p2 {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i drawList} \cell }{the draw list for the window to draw on \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i offset} \cell }{the offset of the window \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i scaling} \cell }{the size scaling \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i p1} \cell }{point one \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i p2} \cell }{point two (opposite corner) \cell }
{\row }
}
}{
Definition at line {\b 450} of file {\b main.cpp}.}\par
}
{\xe \v main\:main.cpp}
{\xe \v main.cpp\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main ()}}
\par
{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The main function where the program starts \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
status code of how the program executed \par
}}}{
Definition at line {\b 572} of file {\b main.cpp}.}\par
}
{\xe \v parsePathIntoRoutine\:main.cpp}
{\xe \v main.cpp\:parsePathIntoRoutine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string parsePathIntoRoutine (const std::vector< {\b Pose2D} > &  {\i path})}}
\par
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
parse a path into a routine {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i path} \cell }{the path to parse \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
the routine from the path \par
}}}{
Definition at line {\b 114} of file {\b main.cpp}.}\par
}
{\xe \v pathToRoutine\:main.cpp}
{\xe \v main.cpp\:pathToRoutine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void pathToRoutine (std::vector< {\b Pose2D} >  {\i path}, std::vector< {\b Move} > &  {\i routine})}}
\par
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
generate a routine from a path {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i path} \cell }{the path to generate a routine from \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i routine} \cell }{the routine to store into \cell }
{\row }
}
}{
Definition at line {\b 90} of file {\b main.cpp}.}\par
}
{\xe \v readAndLog\:main.cpp}
{\xe \v main.cpp\:readAndLog}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void readAndLog (int  {\i socket}, std::mutex &  {\i fieldMutex}, {\b Field} &  {\i field}, std::vector< {\b Pose2D} > &  {\i path})}}
\par
{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Read and log data that gets sent over the TCP socket {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i socket} \cell }{the socket to listen on \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fieldMutex} \cell }{the mutex for the field object \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i field} \cell }{reference to the field object \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i path} \cell }{the path to generate \cell }
{\row }
}
}{
Definition at line {\b 142} of file {\b main.cpp}.}\par
}
{\xe \v ScreenToCoords\:main.cpp}
{\xe \v main.cpp\:ScreenToCoords}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Pose2D} ScreenToCoords (ImVec2  {\i coords}, ImVec2  {\i offset}, ImVec2  {\i scaling})}}
\par
{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Computes a {\b Pose2D} from given screen coordinates {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i coords} \cell }{the coordinates on the window \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i offset} \cell }{the offset of the position of the window on the screen \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i scaling} \cell }{the scaling factor for the window size \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
\par
}}}{
Definition at line {\b 368} of file {\b main.cpp}.}\par
}
{\xe \v sendAngleToQueue\:main.cpp}
{\xe \v main.cpp\:sendAngleToQueue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void sendAngleToQueue (int16_t  {\i angle})}}
\par
{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i angle} \cell }{the angle to send \cell }
{\row }
}
}{
Definition at line {\b 68} of file {\b main.cpp}.}\par
}
{\xe \v sendDistanceToQueue\:main.cpp}
{\xe \v main.cpp\:sendDistanceToQueue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void sendDistanceToQueue (uint16_t  {\i distance})}}
\par
{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds an distance to a queue to be sent to the bot {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i distance} \cell }{the distance to send \cell }
{\row }
}
}{
Definition at line {\b 79} of file {\b main.cpp}.}\par
}
{\xe \v setupImGui\:main.cpp}
{\xe \v main.cpp\:setupImGui}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setupImGui (GLFWwindow *  {\i window})}}
\par
{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Simple function to set up OpenGL and ImGui context {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i window} \cell }{pointer to the GLFW window \cell }
{\row }
}
}{
Definition at line {\b 341} of file {\b main.cpp}.}\par
}
{\xe \v ShowFieldWindow\:main.cpp}
{\xe \v main.cpp\:ShowFieldWindow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ShowFieldWindow (std::mutex *  {\i pillarsMutex}, std::vector< {\b Pose2D} > &  {\i path}, {\b Field} &  {\i field}, std::atomic< bool > &  {\i showNodes}, std::atomic< bool > &  {\i showEdges})}}
\par
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Show the field window on a new window {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pillarsMutex} \cell }{the mutex for pillars \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i path} \cell }{the path to display \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i field} \cell }{the field object \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i showNodes} \cell }{whether to show nodes or not (atomic reference) \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i showEdges} \cell }{whether to show edges of the graph or not (atmoic reference) \cell }
{\row }
}
}{
Definition at line {\b 479} of file {\b main.cpp}.}\par
}
{\xe \v ShowPillarOnWindow\:main.cpp}
{\xe \v main.cpp\:ShowPillarOnWindow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ShowPillarOnWindow (ImDrawList *  {\i drawList}, {\b Pillar}  {\i pillar}, ImU32  {\i color}, ImVec2  {\i offset}, ImVec2  {\i scaling})}}
\par
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Show a given pillar on the window. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i drawList} \cell }{the window to draw a pillar (circle) on \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pillar} \cell }{the pillar which stores the given position and radius \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i color} \cell }{the color to draw it as \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i offset} \cell }{the offset of the window \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i scaling} \cell }{the sizing ration for the window \cell }
{\row }
}
}{
Definition at line {\b 408} of file {\b main.cpp}.}\par
}
{\xe \v stopClient\:main.cpp}
{\xe \v main.cpp\:stopClient}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::atomic< bool > stopClient (false )}}
\par
{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v queueMutex\:main.cpp}
{\xe \v main.cpp\:queueMutex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::mutex queueMutex}}
\par
{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 42} of file {\b main.cpp}.}\par
}
{\xe \v sendCondition\:main.cpp}
{\xe \v main.cpp\:sendCondition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::condition_variable sendCondition}}
\par
{\bkmkstart AAAAAAAACN}
{\bkmkend AAAAAAAACN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 43} of file {\b main.cpp}.}\par
}
{\xe \v sendQueue\:main.cpp}
{\xe \v main.cpp\:sendQueue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::queue<std::string> sendQueue}}
\par
{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 41} of file {\b main.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
main.cpp\par \pard\plain 
{\tc\tcl2 \v /home/calebk/Documents/coding/RoombaController/src/main.cpp}
{\xe \v /home/calebk/Documents/coding/RoombaController/src/main.cpp}
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "../include/imgui/imgui.h"}\par
00002 {\cf21 #include "../include/imgui/backends/imgui_impl_glfw.h"}\par
00003 {\cf21 #include "../include/imgui/backends/imgui_impl_opengl3.h"}\par
00004 {\cf21 #include <GLFW/glfw3.h>}\par
00005 {\cf21 #include "Pose2D.hpp"}\par
00006 {\cf21 #include "Node.hpp"}\par
00007 {\cf21 #include "Pillar.hpp"}\par
00008 {\cf21 #include "Hole.hpp"}\par
00009 {\cf21 #include "Field.hpp"}\par
00010 {\cf21 #include <vector>}\par
00011 {\cf21 #include <netinet/in.h>}\par
00012 {\cf21 #include <chrono>}\par
00013 {\cf21 #include <sys/socket.h>}\par
00014 {\cf21 #include <unistd.h>}\par
00015 {\cf21 #include <arpa/inet.h>}\par
00016 {\cf21 #include <fstream>}\par
00017 {\cf21 #include <iostream>}\par
00018 {\cf21 #include <thread>}\par
00019 {\cf21 #include <queue>}\par
00020 {\cf21 #include <condition_variable>}\par
00021 {\cf21 #include <atomic>}\par
00022 {\cf21 #include <sstream>}\par
00023 \par
00024 {\cf21 #define BOT_CONNECT 0}\par
00025 {\cf21 #if BOT_CONNECT}\par
00026 {\cf21     #define ADDRESS "192.168.1.1"}\par
00027 {\cf21     #define PORT 288}\par
00028 {\cf21 #else}\par
00029 {\cf21     #define ADDRESS "127.0.0.1"}\par
00030 {\cf21     #define PORT  65432}\par
00031 {\cf21 #endif}\par
00032 \par
00033 {\cf17 enum} MovementType \{\par
00034     MOVE_FORWARD,\par
00035     MOVE_BACKWARDS,\par
00036     MOVE_FORWARD_SMART,\par
00037     TURN_TO_ANGLE,\par
00038     SCAN\par
00039 \};\par
00040 \par
00041 std::queue<std::string> sendQueue;\par
00042 std::mutex queueMutex;\par
00043 std::condition_variable sendCondition;\par
00044 \par
00045 {\cf17 struct }Move \{\par
00046     {\cf18 double} quantity;\par
00047     MovementType type;\par
00048 \};\par
00049 \par
00050 std::atomic<bool> stopClient({\cf17 false});\par
00051 \par
00056 {\cf18 void} addToQueue({\cf17 const} std::string& message) \{\par
00057     {\cf20 // std::cout << message << std::endl;}\par
00058     queueMutex.lock();\par
00059     std::cout << message << std::endl;\par
00060     sendQueue.push(message);\par
00061     queueMutex.unlock();\par
00062 \}\par
00063 \par
00068 {\cf18 void} sendAngleToQueue(int16_t angle) \{\par
00069     {\cf18 char} buff[8];\par
00070     sprintf(buff, {\cf22 "t%03d"}, angle);\par
00071     {\cf20 // std::cout << std::string(buff) << std::endl;}\par
00072     sendQueue.emplace(buff);\par
00073 \}\par
00074 \par
00079 {\cf18 void} sendDistanceToQueue(uint16_t distance) \{\par
00080     {\cf18 char} buff[8];\par
00081     sprintf(buff, {\cf22 "r%03d"}, distance);\par
00082     sendQueue.emplace(buff);\par
00083 \}\par
00084 \par
00090 {\cf18 void} pathToRoutine(std::vector<Pose2D> path, std::vector<Move>& routine) \{\par
00091     {\cf20 // start at 1 so that we can gurantee that we can look back.}\par
00092     {\cf18 double} previousEndHeading = path[0].getHeading();\par
00093     {\cf19 for} ({\cf18 size_t} move = 1; move < ((path.size() - 1)*2); move += 2) \{\par
00094         {\cf20 // for every point we want to point and move}\par
00095         Pose2D pointOld = path[move / 2];\par
00096         Pose2D pointNew = path[(move / 2) + 1];\par
00097         {\cf20 // angle to turn to}\par
00098         {\cf18 double} newHeading = pointNew.angleTo(pointOld);\par
00099         {\cf18 double} angle = newHeading - previousEndHeading;\par
00100         previousEndHeading = newHeading;\par
00101 \par
00102         {\cf20 // magnitude}\par
00103         {\cf18 double} magnitude = pointNew.distanceTo(pointOld);\par
00104         routine.push_back((Move) \{.quantity = angle, .type = TURN_TO_ANGLE\});\par
00105         routine.push_back((Move) \{.quantity = magnitude, .type = MOVE_FORWARD_SMART\});\par
00106     \}\par
00107 \}\par
00108 \par
00114 std::string parsePathIntoRoutine({\cf17 const} std::vector<Pose2D>& path) \{\par
00115     std::stringstream toSend;\par
00116     std::vector<Move> routine;\par
00117     {\cf20 // std::cout << "routine length: " << routine.size() << std::endl;}\par
00118     pathToRoutine(path, routine);\par
00119 \par
00120     toSend << {\cf22 "R"};\par
00121 \par
00122     {\cf19 for} (uint8_t i = 0; i < routine.size(); i++) \{\par
00123         {\cf17 static} {\cf18 char} buffer[50];\par
00124         {\cf20 // sprintf(buffer, "p %0.3f %0.3f " , path[i].getX(), path[i].getY());}\par
00125         {\cf20 // // routine[i] is all 0}\par
00126         sprintf(buffer, {\cf22 " %0.3f %c "}, routine[i].quantity, routine[i].type + {\cf23 'a'});\par
00127         toSend << std::string(buffer);\par
00128     \}\par
00129 \par
00130     toSend << {\cf22 "R"};\par
00131 \par
00132     {\cf19 return} toSend.str();\par
00133 \}\par
00134 \par
00142 {\cf18 void} readAndLog({\cf18 int} socket, std::mutex& fieldMutex, Field& field, std::vector<Pose2D>& path) \{\par
00143     {\cf17 const} uint16_t BUFF_SIZE = 1024;\par
00144 \par
00145     {\cf17 static} {\cf18 char} name_buff[50];\par
00146   time_t now = time(0);\par
00147   strftime(name_buff, {\cf17 sizeof}(name_buff), {\cf22 "log/%Y%m%d_%H%M%S.log"}, localtime(&now));\par
00148   std::string str_name(name_buff);\par
00149 \par
00150   std::ofstream logFile(str_name);\par
00151 \par
00152   {\cf19 while} (!(stopClient.load())) \{\par
00153 \par
00154     {\cf18 char} buff[BUFF_SIZE];\par
00155 \par
00156     {\cf20 // expect a "Handshake" response to be echoed}\par
00157     {\cf18 size_t} bytesRead = read(socket, buff, BUFF_SIZE);\par
00158 \par
00159     std::string response(buff, bytesRead);\par
00160 \par
00161     {\cf19 if} (bytesRead > 0) \{\par
00162         logFile << response;\par
00163     \}\par
00164 \par
00165     std::istringstream stream(response);\par
00166     {\cf18 char} tag;\par
00167     {\cf19 while} (stream >> tag) \{\par
00168     {\cf19 switch}(tag) \{\par
00169         {\cf19 case} {\cf23 'F'}:\par
00170             {\cf20 // send the routine}\par
00171             \{\par
00172                 {\cf20 // generate path and return it}\par
00173                 fieldMutex.lock();\par
00174 \par
00175                 field.discretizeGraph();\par
00176                 field.weightGraph();\par
00177 \par
00178                 path.clear();\par
00179                 std::vector<Pose2D> pathOne = field.makePath();\par
00180                 {\cf19 for} (uint16_t i = 0; i < pathOne.size(); i++) \{\par
00181                     path.push_back(pathOne[i]);\par
00182                 \}\par
00183 \par
00184                 {\cf20 /*}\par
00185 {\cf20                 Pose2D oldCenter = field.getDesiredDestination();}\par
00186 {\cf20                 if (path.empty()) \{}\par
00187 {\cf20                     // try a new desired position until its not empty}\par
00188 {\cf20                     for (uint8_t i = 0; i < 10; i += 5) \{}\par
00189 {\cf20                         for (double j = 0; j < 2 * M_PI; j += M_PI * 1/4) \{}\par
00190 {\cf20                             Pose2D newDesired = Pose2D::fromPolar(i, j);}\par
00191 {\cf20                             newDesired.plus(oldCenter);}\par
00192 {\cf20                             if (!Field::outOfBounds(newDesired)) \{}\par
00193 {\cf20                                 field.updateDesired(newDesired);}\par
00194 {\cf20                                 field.discretizeGraph();}\par
00195 {\cf20                                 field.weightGraph();}\par
00196 {\cf20                                 path = field.makePath();}\par
00197 {\cf20                                 if (!path.empty()) \{}\par
00198 {\cf20                                     sendQueue.push(parsePathIntoRoutine(path));}\par
00199 {\cf20                                     break;}\par
00200 {\cf20                                 \}}\par
00201 {\cf20                             \}}\par
00202 {\cf20                         \}}\par
00203 {\cf20                     \}}\par
00204 {\cf20                 \}}\par
00205 {\cf20                  */}\par
00206 \par
00207                 fieldMutex.unlock();\par
00208             \}\par
00209             {\cf19 break};\par
00210         {\cf19 case} {\cf23 'o'}:\par
00211             \{\par
00212             fieldMutex.lock();\par
00213             Pillar toAdd = Pillar::parseFromStream(stream);\par
00214             {\cf20 // std::cout << "x: " << toAdd.getX() << " y: " << toAdd.getY() << " radius: " << toAdd.getRadius() << std::endl;}\par
00215             toAdd.getPose().transformForPose(field.getBotPose().getPose());\par
00216             field.addPillar(toAdd);\par
00217             fieldMutex.unlock();\par
00218             \}\par
00219             {\cf19 break};\par
00220         {\cf19 case} {\cf23 'd'}:\par
00221             \{\par
00222                 Pose2D other = Pose2D::parseFromStream(stream);\par
00223                 field.updateDesired(other);\par
00224             \}\par
00225             {\cf19 break};\par
00226         {\cf19 case} {\cf23 'E'}:\par
00227             \{\par
00228             {\cf18 double} m;\par
00229             {\cf18 char} cardinality;\par
00230             {\cf19 if} (stream >> m >> cardinality) \{\par
00231                 field.addEdgeMeasurement(m, (Cardinality) cardinality);\par
00232             \}\par
00233             {\cf20 // first term is the raw X or Y value next value is the direction}\par
00234             \}\par
00235             {\cf19 break};\par
00236         {\cf19 case} {\cf23 'h'}:\par
00237             \{\par
00238             fieldMutex.lock();\par
00239             {\cf20 // data is coming in the format " X Y Theta "}\par
00240             Pose2D holeMeasurment = Pose2D::parseFromStream(stream);\par
00241             holeMeasurment.plus(field.getBotPose().getPose());\par
00242             field.getManager().addPoint(holeMeasurment);\par
00243             fieldMutex.unlock();\par
00244             \}\par
00245             {\cf19 break};\par
00246         {\cf19 case} {\cf23 'H'}:\par
00247             \{\par
00248             {\cf20 // data is coming in the format " X1 Y1 X2 Y2 "}\par
00249             fieldMutex.lock();\par
00250             {\cf18 double} x1, y1, x2, y2;\par
00251             {\cf19 if} (stream >> x1 >> y1 >> x2 >> y2) \{\par
00252                 Pose2D one(x1, y1);\par
00253                 Pose2D two(x2, y2);\par
00254                 one.plus(field.getBotPose().getPose());\par
00255                 two.plus(field.getBotPose().getPose());\par
00256                 Hole hole(one, two, one.distanceTo(two) / sqrt(2));\par
00257                 field.getManager().addHole(hole);\par
00258             \}\par
00259             fieldMutex.unlock();\par
00260             \}\par
00261             {\cf19 break};\par
00262         {\cf19 case} {\cf23 'b'}:\par
00263             \{\par
00264             fieldMutex.lock();\par
00265             field.updateBotPose(Pose2D::parseFromStream(stream));\par
00266             std::cout << {\cf22 "recieved bot pose: "} << field.getBotPose().getPose() << std::endl;\par
00267             fieldMutex.unlock();\par
00268             \}\par
00269             {\cf19 break};\par
00270         {\cf19 default}:\par
00271             logFile << tag;\par
00272             {\cf19 break};\par
00273     \}\par
00274     \}\par
00275 \par
00276     std::this_thread::sleep_for(std::chrono::milliseconds(5));\par
00277     {\cf20 // no matter what we are going to log this in a file, however we should also update certain fields}\par
00278 \par
00279   \}\par
00280 \par
00281   logFile.close();\par
00282 \par
00283 \}\par
00284 \par
00291 {\cf18 void} connectTCP(Field& field, std::mutex& fieldMutex, std::vector<Pose2D>& path) \{\par
00292  {\cf18 int} clientSocket = socket(AF_INET, SOCK_STREAM, 0);\par
00293   sockaddr_in serverAddress\{\par
00294     .sin_family = AF_INET,\par
00295     .sin_port = htons(PORT),\par
00296     .sin_addr = inet_addr(ADDRESS)\par
00297   \};\par
00298 \par
00299   {\cf20 // https://beej.us/guide/bgnet/html/#blocking}\par
00300   {\cf20 // fcntl(clientSocket, F_SETFL, O_NONBLOCK);}\par
00301     {\cf18 bool} connected = {\cf17 false};\par
00302     {\cf19 while} (!connected) \{\par
00303     {\cf19 try} \{\par
00304         {\cf19 if}(connect(clientSocket, ({\cf17 struct} sockaddr*)& serverAddress, {\cf17 sizeof}(serverAddress))) \{\par
00305             {\cf19 throw} std::exception();\par
00306         \}\par
00307         connected = {\cf17 true};\par
00308     \}\par
00309     {\cf19 catch} (std::exception& e) \{\par
00310         std::this_thread::sleep_for(std::chrono::milliseconds(500));\par
00311         connected = {\cf17 false};\par
00312     \}\par
00313 \par
00314     \}\par
00315 \par
00316   {\cf20 // spawn read and log thread here}\par
00317   std::thread readThread(readAndLog, std::ref(clientSocket), std::ref(fieldMutex), std::ref(field), std::ref(path));\par
00318 \par
00319   {\cf19 while}(!stopClient.load()) \{\par
00320     {\cf19 if} (!sendQueue.empty()) \{\par
00321         std::string message = sendQueue.front();\par
00322         {\cf19 if} (message.compare({\cf22 "q"}) == 0) \{\par
00323             stopClient.store({\cf17 true});\par
00324         \}\par
00325         sendQueue.pop();\par
00326         send(clientSocket, message.c_str(), message.length(), 0);\par
00327     \}\par
00328 \par
00329     std::this_thread::sleep_for(std::chrono::milliseconds(20));\par
00330     \}\par
00331 \par
00332 \par
00333   readThread.join();\par
00334   close(clientSocket);\par
00335 \}\par
00336 \par
00341 {\cf18 void} setupImGui(GLFWwindow* window) \{\par
00342     IMGUI_CHECKVERSION();\par
00343     ImGui::CreateContext();\par
00344     ImGuiIO& io = ImGui::GetIO(); (void)io;\par
00345     ImGui::StyleColorsDark();\par
00346     ImGui_ImplGlfw_InitForOpenGL(window, {\cf17 true});\par
00347     ImGui_ImplOpenGL3_Init({\cf22 "#version 130"});\par
00348 \}\par
00349 \par
00357 {\cf18 void} DrawCircle(ImDrawList* drawList, {\cf17 const} ImVec2& center, {\cf18 float} radius, ImU32 color) \{\par
00358   drawList->AddCircle(center, radius, color, 0, 0.2f);\par
00359 \}\par
00360 \par
00368 Pose2D ScreenToCoords(ImVec2 coords, ImVec2 offset, ImVec2 scaling) \{\par
00369     {\cf18 double} x = (coords.x - offset.x) / scaling.x;\par
00370     {\cf18 double} y = MAX_Y - (coords.y - offset.y) / scaling.y;\par
00371     {\cf19 return} \{x, y\};\par
00372 \}\par
00373 \par
00383 ImVec2 coordsToScreen(ImVec2 offset, ImVec2 scaling, {\cf18 double} x, {\cf18 double} y) \{\par
00384     {\cf18 double} xN = offset.x + (scaling.x * x);\par
00385     {\cf18 double} yN = offset.y + (scaling.y * (MAX_Y - y));\par
00386     {\cf19 return} ImVec2(xN, yN);\par
00387 \}\par
00388 \par
00396 ImVec2 coordsToScreen(ImVec2 offset, ImVec2 scaling, {\cf17 const} Pose2D& position) \{\par
00397     {\cf19 return} coordsToScreen(offset, scaling, position.getX(), position.getY());\par
00398 \}\par
00399 \par
00408 {\cf18 void} ShowPillarOnWindow(ImDrawList* drawList, Pillar pillar, ImU32 color, ImVec2 offset, ImVec2 scaling) \{\par
00409     ImVec2 center = coordsToScreen(offset, scaling, pillar.getPose());\par
00410     {\cf18 float} radius = pillar.getRadius() * 2.5;\par
00411     {\cf20 // std::cout << "haven't drawn yet" << std::endl;}\par
00412     DrawCircle(drawList, center, radius, color);\par
00413 \}\par
00414 \par
00423 {\cf18 void} drawBotPose(ImDrawList* drawList, {\cf17 const} Pose2D& botPose, ImVec2 offset, ImVec2 scaling) \{\par
00424     ImU32 color = IM_COL32(144, 238, 144, 200);\par
00425     \par
00426     {\cf20 // calculate the position of the first point}\par
00427     {\cf20 // should be botPose + (botRadius * 1.5 @ bot heading)}\par
00428     {\cf18 double} scaleAmount = 2;\par
00429     Pose2D lineOutOfCenter = Pose2D::fromPolar(BOT_RADIUS * 1.5 * scaleAmount, 0);\par
00430     lineOutOfCenter.transformPose(botPose);\par
00431     {\cf17 const} ImVec2 p1 = coordsToScreen(offset, scaling, lineOutOfCenter);\par
00432     Pose2D sideLine = Pose2D::fromPolar(scaleAmount * BOT_RADIUS * 0.75, Pose2D::degreesToRadians(120));\par
00433     sideLine.transformPose(botPose);\par
00434     {\cf17 const} ImVec2 p2 = coordsToScreen(offset, scaling, sideLine);\par
00435     Pose2D otherSide = Pose2D::fromPolar(BOT_RADIUS * scaleAmount * 0.75, Pose2D::degreesToRadians(240));\par
00436     otherSide.transformPose(botPose);\par
00437     {\cf17 const} ImVec2 p3 = coordsToScreen(offset, scaling, otherSide);\par
00438     \par
00439     drawList->AddTriangle(p1, p2, p3, color);\par
00440 \}\par
00441 \par
00450 {\cf18 void} drawRectangle(ImDrawList* drawList, ImVec2 offset, ImVec2 scaling, {\cf17 const} Pose2D& p1, {\cf17 const} Pose2D& p2) \{\par
00451     {\cf20 // const Pose2D MinPosition = Pose2D(std::min(p1.getX(), p2.getX()), std::min(p1.getY(), p2.getY()));}\par
00452     {\cf20 // const Pose2D MaxPosition = Pose2D(std::max(p1.getX(), p2.getX()), std::max(p1.getY(), p2.getY()));}\par
00453     {\cf20 // fun math time}\par
00454     {\cf17 const} {\cf18 double} xCenter = (p1.getX() + p2.getX()) / 2;\par
00455     {\cf17 const} {\cf18 double} yCenter = (p1.getY() + p2.getY()) / 2;\par
00456     {\cf17 const} {\cf18 double} xDiagonal = (p1.getX() - p2.getX()) / 2;\par
00457     {\cf17 const} {\cf18 double} yDiagonal = (p1.getY() - p2.getY()) / 2;\par
00458 \par
00459     {\cf17 const} Pose2D p3(xCenter - yDiagonal, yCenter + xDiagonal);\par
00460     {\cf17 const} Pose2D p4(xCenter + yDiagonal, yCenter - xDiagonal);\par
00461 \par
00462     {\cf17 const} ImVec2 m1 = coordsToScreen(offset, scaling, p1);\par
00463     {\cf17 const} ImVec2 m2 = coordsToScreen(offset, scaling, p2);\par
00464     {\cf17 const} ImVec2 m3 = coordsToScreen(offset, scaling, p3);\par
00465     {\cf17 const} ImVec2 m4 = coordsToScreen(offset, scaling, p4);\par
00466     {\cf20 //     std::    cout << "p2 position: " << p2.getY() << std::endl;}\par
00467 \par
00468     drawList->AddQuadFilled(m1, m3, m2, m4, IM_COL32(255, 165, 0, 170));\par
00469 \}\par
00470 \par
00479 {\cf18 void} ShowFieldWindow(std::mutex* pillarsMutex, std::vector<Pose2D>& path, Field& field, std::atomic<bool>& showNodes, std::atomic<bool>& showEdges) \{\par
00480     ImGui::Begin({\cf22 "Field"});\par
00481     \par
00482     ImDrawList* drawList = ImGui::GetWindowDrawList();\par
00483     ImVec2 windowSize(MAX_X * 2.5, MAX_Y * 2.5);\par
00484     ImGui::SetWindowSize(windowSize);\par
00485     ImVec2 windowPos = ImGui::GetWindowPos();\par
00486     windowPos.x += windowSize.x / 100;\par
00487     windowPos.y += windowSize.y / 100;\par
00488     ImVec2 offset =  ImVec2(windowPos.x + windowSize.x / 50, windowPos.y - windowSize.y / 50);\par
00489     ImVec2 scalingFactor = ImVec2(windowSize.x / MAX_X, windowSize.y / MAX_Y);\par
00490     \par
00491     pillarsMutex->lock();\par
00492 \par
00493     std::vector<Pillar> pillars = field.getCopyPillars();\par
00494 \par
00495     {\cf19 for} ({\cf17 const} Pillar& pillar: pillars) \{\par
00496         ShowPillarOnWindow(drawList, pillar, IM_COL32(255, 0, 0, 200), offset, scalingFactor);\par
00497     \}\par
00498 \par
00499     std::vector<Hole> holes = field.getManager().getHoles();\par
00500 {\cf20 //     std::cout << "size: " << holes.size() << std::endl; // output 1}\par
00501     {\cf19 for} (Hole hole: holes) \{\par
00502         {\cf20 // std::cout << "X1 Y1 X2 Y2: \{" << hole.getOneSquareCorner().getX() << " " << hole.getOneSquareCorner().getY() << " " << hole.getSecondSquareCorner().getX() << " " << hole.getSecondSquareCorner().getY() << std::endl;}\par
00503         {\cf19 if} (hole.isFoundHole()) \{\par
00504             drawRectangle(drawList, offset, scalingFactor, hole.getOneSquareCorner(), hole.getSecondSquareCorner());\par
00505         \}\par
00506         {\cf19 else} \{\par
00507             std::vector<Hole> subHoles = hole.getSubHolesCopy();\par
00508             {\cf19 for} (Hole holer: subHoles) \{\par
00509                 drawRectangle(drawList, offset, scalingFactor, holer.getOneSquareCorner(), holer.getSecondSquareCorner());\par
00510             \}\par
00511         \}\par
00512     \}\par
00513     \par
00514     drawBotPose(drawList, field.getBotPose().getPose(), offset, scalingFactor);\par
00515 \par
00516     {\cf19 if} (showNodes.load()) \{\par
00517         std::vector<Node<Pose2D> *> nodes = field.getGraph().getNodes();\par
00518 \par
00519         {\cf19 for} (Node<Pose2D> *&node: nodes) \{\par
00520             Pose2D position = node->getData();\par
00521 \par
00522             ImVec2 center = coordsToScreen(offset, scalingFactor, position.getX(), position.getY());\par
00523             {\cf18 float} radius = BOT_RADIUS * 2.5;\par
00524             DrawCircle(drawList, center, radius, IM_COL32(120, 120, 0, 200));\par
00525             {\cf20 // draw a line from every node to the adjacent yes we will double count draws with this}\par
00526             {\cf20 //  std::vector<Node<Pose2D>*> adjacent = getAdj(nodes[nodeIndex]);}\par
00527 \par
00528         \}\par
00529     \}\par
00530 \par
00531     {\cf19 if} (showEdges.load()) \{\par
00532         std::vector<Node<Pose2D> *> nodes = field.getGraph().getNodes();\par
00533         {\cf19 for} (Node<Pose2D> *&node: nodes) \{\par
00534             std::vector<Node<Pose2D> *> adjacent = field.getGraph().getAdj(node);\par
00535             {\cf19 for} (Node<Pose2D> *&adj: adjacent) \{\par
00536                 ImVec2 p1 = coordsToScreen(offset, scalingFactor, node->getData());\par
00537                 ImVec2 p2 = coordsToScreen(offset, scalingFactor, adj->getData());\par
00538                 drawList->AddLine(p1, p2, IM_COL32(100, 100, 100, 100), 2);\par
00539             \}\par
00540         \}\par
00541     \}\par
00542 \par
00543     \par
00544     {\cf19 for} (uint8_t i = 0; i < path.size(); i++) \{\par
00545         {\cf19 if} (i > 0) \{\par
00546             ImVec2 p1 = coordsToScreen(offset, scalingFactor, path[i - 1].getX(), path[i - 1].getY());\par
00547             ImVec2 p2 = coordsToScreen(offset, scalingFactor, path[i].getX(), path[i].getY());\par
00548             drawList->AddLine(p1, p2, IM_COL32(100, 100, 100, 100), 2);\par
00549         \}\par
00550 \par
00551         ImVec2 center = coordsToScreen(offset, scalingFactor, path[i].getX(), path[i].getY());\par
00552         {\cf18 float} radius = BOT_RADIUS * 2.5;\par
00553         DrawCircle(drawList, center, radius, IM_COL32(30, 120, 220, 150));\par
00554     \}\par
00555 \par
00556     pillarsMutex->unlock();\par
00557 \par
00558     ImVec2 mousePos = ImGui::GetMousePos();\par
00559 {\cf20 //  std::string mousePosStr = std::to_string((int)mousePos.x) + ", " + std::to_string((int)mousePos.y);}\par
00560     ImGui::Text({\cf22 "mouse: %d, %d"}, ({\cf18 int})mousePos.x, ({\cf18 int})mousePos.y);\par
00561     Pose2D transformed = ScreenToCoords(ImVec2(({\cf18 int}) mousePos.x, ({\cf18 int}) mousePos.y), offset, scalingFactor);\par
00562     ImGui::Text({\cf22 "Pose on field: %d, %d"}, ({\cf18 int}) transformed.getX(), ({\cf18 int}) transformed.getY());\par
00563 \par
00564     ImGui::End();\par
00565 \}\par
00566 \par
00567 \par
00572 {\cf18 int} main() \{\par
00573   {\cf19 if} (!glfwInit()) {\cf19 return} -1;\par
00574     GLFWwindow* window = glfwCreateWindow(1880, 900, {\cf22 "Roomba Dashboard"}, {\cf17 nullptr}, {\cf17 nullptr});\par
00575     {\cf19 if} (!window) \{ glfwTerminate(); {\cf19 return} -1; \}\par
00576     glfwMakeContextCurrent(window);\par
00577     setupImGui(window);\par
00578     Pose2D desired(0, 0);\par
00579     \par
00580     {\cf20 // used to hold GUI slider values}\par
00581     {\cf18 float} angleSend = 0;\par
00582     {\cf18 int} driveForward = 0;\par
00583 \par
00584     std::atomic<bool> showNodes;\par
00585     showNodes.store({\cf17 false});\par
00586     std::atomic<bool> showEdges;\par
00587     showEdges.store({\cf17 false});\par
00588 \par
00589     {\cf18 char} buffer[100];\par
00590     {\cf18 size_t} buffPtr = 0;\par
00591 \par
00592     std::mutex pillarsMutex;\par
00593     std::vector<Pose2D> path;\par
00594 \par
00595     Field field;\par
00596     {\cf20 // Pose2D toAdd(0, 0, 0);}\par
00597     {\cf20 // graph.addNode(new Node<Pose2D>(toAdd));}\par
00598     {\cf20 // connectTCP(pillars, pillarsMutex, desired);}\par
00599     std::thread tcpConnect(connectTCP, std::ref(field), std::ref(pillarsMutex), std::ref(path));\par
00600     \par
00601     {\cf20 // Main loop}\par
00602     {\cf19 while} (!glfwWindowShouldClose(window)) \{\par
00603         glfwPollEvents();\par
00604 \par
00605         {\cf20 // Start the ImGui frame}\par
00606         ImGui_ImplOpenGL3_NewFrame();\par
00607         ImGui_ImplGlfw_NewFrame();\par
00608         ImGui::NewFrame();\par
00609         {\cf20 // bool open;}\par
00610         {\cf20 // ImGui::ShowDemoWindow(&open);}\par
00611         ShowFieldWindow(&pillarsMutex, path, field, showNodes, showEdges);\par
00612         {\cf20 // std::cout << "About to begin" << std::endl;}\par
00613     \par
00614         {\cf20 // Your ImGui code here}\par
00615         ImGui::Begin({\cf22 "Control Panel"});\par
00616         {\cf20 //  std::cout << "began" << std::endl;}\par
00617         {\cf20 //ImGui::Text("This is some text");}\par
00618         \{\par
00619             {\cf19 if} (ImGui::Button({\cf22 "Forward"})) \{\par
00620                 addToQueue({\cf22 "w"});\par
00621             \}\par
00622 \par
00623             {\cf19 if} (ImGui::Button({\cf22 "Backward"})) \{\par
00624                 addToQueue({\cf22 "s"});\par
00625             \}\par
00626 \par
00627             {\cf19 if} (ImGui::Button({\cf22 "Counter Clockwise"})) \{\par
00628                 addToQueue({\cf22 "a"});\par
00629             \}\par
00630 \par
00631             {\cf19 if} (ImGui::Button({\cf22 "Clockwise"})) \{\par
00632                 addToQueue({\cf22 "d"});\par
00633             \}\par
00634 \par
00635             {\cf19 if} (ImGui::Button({\cf22 "Stop"})) \{\par
00636                 addToQueue({\cf22 " "});\par
00637             \}\par
00638 \par
00639             {\cf19 if} (ImGui::Button({\cf22 "Scan"})) \{\par
00640                 addToQueue({\cf22 "g"});\par
00641             \}\par
00642 \par
00643             {\cf19 if} (ImGui::Button({\cf22 "Auton"})) \{\par
00644                 addToQueue({\cf22 "h"});\par
00645             \}\par
00646 \par
00647             {\cf19 if} (ImGui::Button({\cf22 "Quit all"})) \{\par
00648                 addToQueue({\cf22 "q"});\par
00649             \}\par
00650 \par
00651             {\cf19 if} (ImGui::RadioButton({\cf22 "Show nodes"}, {\cf17 false})) \{\par
00652                 showNodes.store(!showNodes.load());\par
00653             \}\par
00654 \par
00655             {\cf19 if} (ImGui::RadioButton({\cf22 "Show edges"}, {\cf17 false})) \{\par
00656                 showEdges.store(!showEdges.load());\par
00657             \}\par
00658         \}\par
00659 \par
00660         {\cf19 if} (ImGui::Button({\cf22 "Generate path"})) \{\par
00661             pillarsMutex.lock();\par
00662             {\cf20 /*}\par
00663 {\cf20                 std::cout << "desire: " << desired << std::endl;}\par
00664 {\cf20                 for (int i = 0; i < graph->getNodes().size(); i++) \{}\par
00665 {\cf20                 std::cout << "node: " << i << ".  " << graph->getNodes()[i]->getData().getX() << std::endl;}\par
00666 {\cf20             \}}\par
00667 {\cf20 }\par
00668 {\cf20             std::cout << "Attempting to make a path between: " << graph->getNodes().front()->getData().getX() << ", " << graph->getNodes().front()->getData().getY() << std::endl;}\par
00669 {\cf20             std::cout << "To: " <<graph->getNodes().back()->getData().getX() << ", " << graph->getNodes().back()->getData().getY() << std::endl;}\par
00670 {\cf20             // Attempting to make a path between: 0, 0}\par
00671 {\cf20             // To: -100, -100}\par
00672 {\cf20             */}\par
00673             path =  field.makePath();\par
00674             pillarsMutex.unlock();\par
00675             {\cf20 //  std::cout << "PATH NODE SIZE: " << pathNodes.size() << std::endl;}\par
00676             {\cf20 // path.push_back(botPose.getPose());}\par
00677     \}\par
00678 \par
00679     {\cf19 if} (ImGui::Button({\cf22 "send planned path"})) \{\par
00680         {\cf20 // string message = parsePathIntoRoutine(path);}\par
00681         addToQueue(parsePathIntoRoutine(path));\par
00682     \}\par
00683 \par
00684     ImGui::SliderAngle({\cf22 "Turn angle"}, &angleSend);\par
00685 \par
00686         ImGui::InputText({\cf22 "message: "}, buffer, 100);\par
00687 \par
00688     {\cf19 if} (ImGui::Button({\cf22 "send component"})) \{\par
00689         addToQueue(std::string(1, buffer[0]));\par
00690         {\cf19 for} ({\cf18 size_t} i = 0; i < 99; i++) \{\par
00691             {\cf19 if} (buffer[i] == 0) \{\par
00692                 buffPtr = std::min(({\cf18 long}) 0, ({\cf18 long}) i - 1);\par
00693                 {\cf19 break};\par
00694             \}\par
00695             std::swap(buffer[i], buffer[i + 1]);\par
00696         \}\par
00697         buffer[buffPtr] = 0;\par
00698     \}\par
00699 \par
00700     {\cf19 if} (ImGui::Button({\cf22 "Send turn"})) \{\par
00701       sendAngleToQueue((int16_t) (angleSend * 180 / M_PI));\par
00702     \}\par
00703 \par
00704     ImGui::SliderInt({\cf22 "Drive x cm"}, &driveForward, 0, 999);\par
00705 \par
00706     {\cf19 if} (ImGui::Button({\cf22 "Drive x"})) \{\par
00707         sendDistanceToQueue(driveForward);\par
00708     \}\par
00709 \par
00710     {\cf19 if} (ImGui::Button({\cf22 "Discretize"})) \{\par
00711         {\cf20 // std::cout << "HUH: " << pillars[0].getX() << std::endl;}\par
00712        field.discretizeGraph();\par
00713     \}\par
00714 \par
00715     {\cf19 if} (ImGui::Button({\cf22 "Weight"})) \{\par
00716         field.weightGraph();\par
00717     \}\par
00718     {\cf20 // std::cout << "About to end" << std::endl;}\par
00719 \par
00720         ImGui::End();\par
00721         {\cf20 // Render}\par
00722         ImGui::Render();\par
00723         {\cf18 int} display_w, display_h;\par
00724         glfwGetFramebufferSize(window, &display_w, &display_h);\par
00725         glViewport(0, 0, display_w, display_h);\par
00726         glClearColor(0.1f, 0.1f, 0.1f, 1.0f);\par
00727         glClear(GL_COLOR_BUFFER_BIT);\par
00728         ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());\par
00729 \par
00730         glfwSwapBuffers(window);\par
00731 \par
00732         std::this_thread::sleep_for(std::chrono::milliseconds(16));\par
00733     \}\par
00734 \par
00735     stopClient.store({\cf17 true});\par
00736 \par
00737     tcpConnect.join();\par
00738   \par
00739     {\cf20 // Cleanup}\par
00740     ImGui_ImplOpenGL3_Shutdown();\par
00741     ImGui_ImplGlfw_Shutdown();\par
00742     ImGui::DestroyContext();\par
00743     glfwDestroyWindow(window);\par
00744     glfwTerminate();\par
00745 \par
00746     {\cf19 return} 0;\par
00747 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/calebk/Documents/coding/RoombaController/src/Node.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /home/calebk/Documents/coding/RoombaController/src/Node.cpp}
{\xe \v /home/calebk/Documents/coding/RoombaController/src/Node.cpp}
{\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Node.hpp"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Node.cpp\par \pard\plain 
{\tc\tcl2 \v /home/calebk/Documents/coding/RoombaController/src/Node.cpp}
{\xe \v /home/calebk/Documents/coding/RoombaController/src/Node.cpp}
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //}\par
00002 {\cf20 // Created by caleb on 11/9/21.}\par
00003 {\cf20 //}\par
00004 \par
00005 {\cf21 #include "Node.hpp"}\par
00006 \par
00007 \par
00008 {\cf17 template}<{\cf17 typename} V>\par
00009 Node<V>::Node(V data) \{\par
00010     this->data = data;\par
00011 \}\par
00012 \par
00013 {\cf17 template}<{\cf17 typename} V>\par
00014 V Node<V>::getData() \{\par
00015     {\cf19 return} data;\par
00016 \}\par
00017 \par
00018 {\cf17 template}<{\cf17 typename} V>\par
00019 {\cf18 void} Node<V>::SetData(V newData) \{\par
00020     data = newData;\par
00021 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/calebk/Documents/coding/RoombaController/src/Node.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v /home/calebk/Documents/coding/RoombaController/src/Node.hpp}
{\xe \v /home/calebk/Documents/coding/RoombaController/src/Node.hpp}
{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Pose2D.hpp"}\par
{\f2 #include "Node.cpp"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Node< V >}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Node.hpp\par \pard\plain 
{\tc\tcl2 \v /home/calebk/Documents/coding/RoombaController/src/Node.hpp}
{\xe \v /home/calebk/Documents/coding/RoombaController/src/Node.hpp}
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //}\par
00002 {\cf20 // Created by caleb on 11/9/21.}\par
00003 {\cf20 //}\par
00004 \par
00005 {\cf21 #ifndef ANOTHERGRAPH_NODE_H}\par
00006 {\cf21 #define ANOTHERGRAPH_NODE_H}\par
00007 \par
00008 \par
00009 {\cf21 #include "Pose2D.hpp"}\par
00010 \par
00016 {\cf17 template} <{\cf17 typename} V>\par
00017 {\cf17 class }Node \{\par
00018     {\cf17 private}:\par
00022     V data;\par
00023 \par
00024     {\cf17 public}:\par
00029     Node(V data);\par
00030 \par
00034     V getData();\par
00035 \par
00040     {\cf18 void} SetData(V newData);\par
00041 \};\par
00042 \par
00043 {\cf21 #include "Node.cpp"}\par
00044 \par
00045 {\cf21 #endif }{\cf20 //ANOTHERGRAPH_NODE_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/calebk/Documents/coding/RoombaController/src/Pillar.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /home/calebk/Documents/coding/RoombaController/src/Pillar.cpp}
{\xe \v /home/calebk/Documents/coding/RoombaController/src/Pillar.cpp}
{\bkmkstart AAAAAAAACR}
{\bkmkend AAAAAAAACR}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Pillar.hpp"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Pillar.cpp\par \pard\plain 
{\tc\tcl2 \v /home/calebk/Documents/coding/RoombaController/src/Pillar.cpp}
{\xe \v /home/calebk/Documents/coding/RoombaController/src/Pillar.cpp}
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 // }\par
00002 {\cf20 // Created By Caleb on 10/24/2024}\par
00003 {\cf20 //}\par
00004 \par
00005 {\cf21 #include "Pillar.hpp"}\par
00006 \par
00007 Pillar::Pillar() \{\par
00008    this->position = Pose2D(0, 0, 0);\par
00009     this->radius = 0;\par
00010 \}\par
00011 \par
00012 Pillar::Pillar({\cf17 const} {\cf18 double} x, {\cf17 const} {\cf18 double} y, {\cf17 const} {\cf18 double} heading, {\cf17 const} {\cf18 double} radius) \{\par
00013     this->radius = radius;\par
00014     Pose2D pose(x, y, heading);\par
00015     this->position = pose;\par
00016 \}\par
00017 \par
00018 Pillar::Pillar({\cf17 const} Pose2D& position, {\cf17 const} {\cf18 double} radius) \{\par
00019     this->position = position;\par
00020     this->radius = radius;\par
00021 \}\par
00022 \par
00023 Pillar::Pillar({\cf17 const} {\cf18 double} x, {\cf17 const} {\cf18 double} y, {\cf17 const} {\cf18 double} radius) \{\par
00024     Pose2D pose(x, y);\par
00025     this->position = pose;\par
00026   this->radius = radius;\par
00027 \}\par
00028 \par
00029 Pose2D& Pillar::getPose() \{\par
00030   {\cf19 return} this->position;\par
00031 \}\par
00032 \par
00033 {\cf18 double} Pillar::getX() \{\par
00034     {\cf19 return} this->position.getX();\par
00035 \}\par
00036 \par
00037 {\cf18 double} Pillar::getY() \{\par
00038     {\cf19 return} this->position.getY();\par
00039 \}\par
00040 \par
00041 {\cf18 double} Pillar::getRadius(){\cf17  const }\{\par
00042     {\cf19 return} this->radius;\par
00043 \}\par
00044 \par
00045 {\cf18 void} Pillar::setRadius({\cf18 double} newRadius) \{\par
00046     this->radius = newRadius;\par
00047 \}\par
00048 \par
00049 \par
00050 Pillar Pillar::parseFromStream(std::istringstream& stream) \{\par
00051     {\cf18 double} x, y, heading, radius;\par
00052     {\cf19 if} (stream >> x >> y >> heading >> radius) \{\par
00053         {\cf19 return} Pillar(x, y, heading, radius);\par
00054     \}\par
00055     {\cf19 return} Pillar(0, 0, 0);\par
00056 \}\par
00057 \par
00058 {\cf18 void} Pillar::setPosition({\cf17 const} Pose2D& newPosition) \{\par
00059     this->position = newPosition;\par
00060 \}\par
00061 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/calebk/Documents/coding/RoombaController/src/Pillar.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v /home/calebk/Documents/coding/RoombaController/src/Pillar.hpp}
{\xe \v /home/calebk/Documents/coding/RoombaController/src/Pillar.hpp}
{\bkmkstart AAAAAAAACS}
{\bkmkend AAAAAAAACS}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Pose2D.hpp"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Pillar}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Pillar.hpp\par \pard\plain 
{\tc\tcl2 \v /home/calebk/Documents/coding/RoombaController/src/Pillar.hpp}
{\xe \v /home/calebk/Documents/coding/RoombaController/src/Pillar.hpp}
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //}\par
00002 {\cf20 // Created by caleb on 10/24/2024}\par
00003 {\cf20 //}\par
00004 \par
00005 {\cf21 #ifndef PILLAR_H}\par
00006 {\cf21 #define PILLAR_H}\par
00007 \par
00008 {\cf21 #include "Pose2D.hpp"}\par
00009 \par
00014 {\cf17 class }Pillar \{\par
00015   {\cf17 protected}:\par
00019     Pose2D position;\par
00020 \par
00024     {\cf18 double} radius;\par
00025 \par
00026   {\cf17 public}:\par
00030     Pillar();\par
00031 \par
00037     Pillar({\cf17 const} Pose2D& position, {\cf18 double} radius);\par
00038 \par
00046     Pillar({\cf18 double} x, {\cf18 double} y, {\cf18 double} heading, {\cf18 double} radius);\par
00047 \par
00054     Pillar({\cf18 double} x, {\cf18 double} y, {\cf18 double} radius);\par
00055     {\cf20 //~Pillar();}\par
00061     Pose2D& getPose();\par
00062 \par
00066     {\cf18 double} getX();\par
00067 \par
00071     {\cf18 double} getY();\par
00072 \par
00076     [[nodiscard]] {\cf18 double} getRadius() {\cf17 const};\par
00077 \par
00082     {\cf18 void} setRadius({\cf18 double} newRadius);\par
00083 \par
00088     {\cf18 void} setPosition({\cf17 const} Pose2D& newPosition);\par
00089 \par
00096     {\cf17 static} Pillar parseFromStream(std::istringstream& stream);\par
00097 \};\par
00098 \par
00099 {\cf21 #endif }{\cf20 //PILLAR_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/calebk/Documents/coding/RoombaController/src/Pose2D.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /home/calebk/Documents/coding/RoombaController/src/Pose2D.cpp}
{\xe \v /home/calebk/Documents/coding/RoombaController/src/Pose2D.cpp}
{\bkmkstart AAAAAAAACT}
{\bkmkend AAAAAAAACT}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Pose2D.hpp"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &os, const {\b Pose2D} &d)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Rectangle} {\b makeRectangleFromLine} (const {\b Pose2D} &L1, const {\b Pose2D} &L2, double width)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v makeRectangleFromLine\:Pose2D.cpp}
{\xe \v Pose2D.cpp\:makeRectangleFromLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Rectangle} makeRectangleFromLine (const {\b Pose2D} &  {\i L1}, const {\b Pose2D} &  {\i L2}, double  {\i width})}}
\par
{\bkmkstart AAAAAAAACU}
{\bkmkend AAAAAAAACU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Makes a rectangle from a line {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i L1} \cell }{One bound of the line \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i L2} \cell }{Another bound of the line \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i width} \cell }{the width of the rectangle \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
a rectangle with the the line in the middle and a width of the width passed in \par
}}}{
Definition at line {\b 248} of file {\b Pose2D.cpp}.}\par
}
{\xe \v operator<<\:Pose2D.cpp}
{\xe \v Pose2D.cpp\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & operator<< (std::ostream &  {\i os}, const {\b Pose2D} &  {\i d})}}
\par
{\bkmkstart AAAAAAAACV}
{\bkmkend AAAAAAAACV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To string for a pose2D {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i os} \cell }{output stream \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i d} \cell }{the pose2D to reference \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
\par
}}}{
Definition at line {\b 230} of file {\b Pose2D.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Pose2D.cpp\par \pard\plain 
{\tc\tcl2 \v /home/calebk/Documents/coding/RoombaController/src/Pose2D.cpp}
{\xe \v /home/calebk/Documents/coding/RoombaController/src/Pose2D.cpp}
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //}\par
00002 {\cf20 // Created by caleb on 10/24/2024}\par
00003 {\cf20 //}\par
00004 \par
00005 {\cf21 #include "Pose2D.hpp"}\par
00006 \par
00007 Pose2D::Pose2D({\cf18 double} x, {\cf18 double} y, {\cf18 double} heading) \{\par
00008   this->x = x;\par
00009   this->y = y;\par
00010   this->heading = heading;\par
00011 \}\par
00012 \par
00013 Pose2D::Pose2D({\cf18 double} x, {\cf18 double} y) \{\par
00014   this->x = x;\par
00015   this->y = y;\par
00016 \}\par
00017 \par
00018 Pose2D::Pose2D() \{\par
00019     this->x = 0;\par
00020     this->y = 0;\par
00021     this->heading = 0;\par
00022 \}\par
00023 \par
00024 {\cf18 bool} Pose2D::isOnLine(Pose2D LineEnd1, Pose2D LineEnd2) \{\par
00025     {\cf18 double} y1 = LineEnd1.getY();\par
00026     {\cf18 double} x1 = LineEnd1.getX();\par
00027 \par
00028     {\cf18 double} y2 = LineEnd2.getY();\par
00029     {\cf18 double} x2 = LineEnd2.getX();\par
00030 \par
00031     {\cf19 if} (x1 > x2) \{\par
00032     {\cf20 // need to swap}\par
00033     {\cf18 double} holder = x1;\par
00034     x1 = x2;\par
00035     x2 = holder;\par
00036     holder = y1;\par
00037     y1 = y2;\par
00038     y2 = holder;\par
00039     \}\par
00040 \par
00041     {\cf20 // base case of the line just being y = }\par
00042     {\cf19 if} (std::abs(y1 - y2) < 0.1) \{\par
00043     {\cf20 // straight y = line}\par
00044     {\cf19 return} (this->getX() < x2 && this->getX() > x1);\par
00045     \}\par
00046 \par
00047     {\cf20 // case where the line is just x =}\par
00048     {\cf19 else} {\cf19 if} (std::abs(x1 - x2) < 0.1) \{\par
00049     {\cf19 return} (this->getY() < std::fmax(y1, y2) && this->getY() > std::fmin(y1, y2));\par
00050     \}\par
00051 \par
00052     {\cf20 // y = mx + b line can be formed}\par
00053     {\cf19 else} \{\par
00054     {\cf18 double} m, b;    \par
00055     {\cf20 // find the equation of the line and plugin this coordinates into it to see if it is close to on the line}\par
00056     m = (y2 - y1) / (x2 - x1);\par
00057     b = y1 - m * x1; {\cf20 // B?}\par
00058         \par
00059     {\cf18 double} wouldBeY = m * this->getX() + b;\par
00060     {\cf19 return} fabs(wouldBeY - this->getY()) < 0.1;\par
00061     \}\par
00062 \}\par
00063 \par
00064 Pose2D::Pose2D({\cf17 const} Pose2D& position) \{\par
00065     this->x = position.x;\par
00066     this->y = position.y;\par
00067     this->heading = position.heading;\par
00068 \}\par
00069 \par
00070 {\cf20 /*}\par
00071 {\cf20 Pose2D::Pose2D(Pose2D* position) \{}\par
00072 {\cf20   this->x = position->x;}\par
00073 {\cf20   this->y = position->y;}\par
00074 {\cf20   this->heading = position->heading;}\par
00075 {\cf20 \}}\par
00076 {\cf20 */}\par
00077 \par
00078 {\cf18 double} Pose2D::angleTo({\cf17 const} Pose2D& other){\cf17  const }\{\par
00079   {\cf19 return} atan2(other.y - this->y, other.x - this->x);  \par
00080 \}\par
00081 \par
00082 {\cf18 void} Pose2D::addAngle({\cf18 double} angle) \{\par
00083     this->heading += angle;\par
00084 \}\par
00085 \par
00086 {\cf18 double} Pose2D::distanceTo({\cf17 const} Pose2D& other){\cf17  const }\{\par
00087   {\cf19 return} hypot(this->x - other.x, this->y - other.y);\par
00088 \}\par
00089 \par
00090 {\cf18 double} Pose2D::squareOfDistanceTo({\cf17 const} Pose2D& other){\cf17  const }\{\par
00091   {\cf19 return} pow(other.x -this->x, 2) + pow(other.y - this->y, 2);\par
00092 \}\par
00093 \par
00094 {\cf18 void} Pose2D::transformForPose({\cf17 const} Pose2D& other) \{\par
00095     rotateByPose(other);\par
00096     this->x += other.x;\par
00097     this->y += other.y;\par
00098 \}\par
00099 \par
00100 {\cf18 void} Pose2D::plus({\cf17 const} Pose2D& other) \{\par
00101     this->x += other.x;\par
00102     this->y += other.y;\par
00103     this->heading += other.heading;\par
00104 \}\par
00105 \par
00106 Pose2D Pose2D::clone(){\cf17  const }\{\par
00107   {\cf19 return} \{this->x, this->y, this->heading\};\par
00108 \}\par
00109 \par
00110 {\cf18 void} Pose2D::vecAdd({\cf17 const} {\cf18 double} angle, {\cf17 const} {\cf18 double} magnitude) \{\par
00111     this->x += magnitude * cos(angle);\par
00112     this->y += magnitude * sin(angle);\par
00113 \}\par
00114 \par
00115 \par
00116 {\cf18 void} Pose2D::rotateByAngle({\cf18 double} angle) \{\par
00117   {\cf18 double} newX = this->x * cos(angle) - this->y * sin(angle);\par
00118   this->y = this->x * sin(angle) + this->y * cos(angle);\par
00119   this->x = newX;\par
00120   this->heading += angle;\par
00121 \}\par
00122 \par
00123 {\cf18 void} Pose2D::plusCoord({\cf17 const} Pose2D& other) \{\par
00124     this->x += other.x;\par
00125     this->y += other.y;\par
00126 \}\par
00127 \par
00128 {\cf18 void} Pose2D::rotateByPose({\cf17 const} Pose2D& rotation) \{\par
00129   rotateByAngle(rotation.heading);\par
00130 \}\par
00131 \par
00132 {\cf18 void} Pose2D::translateByPose({\cf17 const} Pose2D& translation) \{\par
00133   this->x += translation.x;\par
00134   this->y += translation.y;\par
00135 \} \par
00136 \par
00137 {\cf18 void} Pose2D::translateByMagnitude({\cf18 double} magnitude) \{\par
00138   this->x += magnitude * cos(this->heading);\par
00139   this->y += magnitude * sin(this->heading);\par
00140 \}\par
00141 \par
00142 {\cf18 void} Pose2D::transformPose({\cf17 const} Pose2D& modifier) \{\par
00143   translateByPose(modifier);\par
00144   rotateByPose(modifier);\par
00145 \}\par
00146 \par
00147 {\cf18 double} Pose2D::getX(){\cf17  const }\{\par
00148   {\cf19 return} x;\par
00149 \}\par
00150 \par
00151 {\cf18 double} Pose2D::getY(){\cf17  const }\{\par
00152   {\cf19 return} y;\par
00153 \}\par
00154 \par
00155 {\cf18 double} Pose2D::getHeading(){\cf17  const }\{\par
00156   {\cf19 return} heading;\par
00157 \}\par
00158 \par
00159 {\cf18 void} Pose2D::setHeading({\cf18 double} angle) \{\par
00160     this->heading = angle;\par
00161 \}\par
00162 \par
00163 {\cf18 void} Pose2D::setX({\cf18 double} x) \{\par
00164     this->x = x;\par
00165 \}\par
00166 \par
00167 {\cf18 void} Pose2D::setY({\cf18 double} y) \{\par
00168     this->y = y;\par
00169 \}\par
00170 \par
00171 uint8_t Pose2D::getQuadrant(){\cf17  const }\{\par
00172     {\cf19 if} (x == 0 || y == 0) \{\par
00173         {\cf19 return} 0;\par
00174     \}\par
00175     {\cf19 if} (x < 0) \{\par
00176         {\cf19 if} (y < 0) \{\par
00177             {\cf19 return} 3;\par
00178         \}\par
00179         {\cf19 return} 2;\par
00180     \}\par
00181     {\cf19 if} (y > 0) \{\par
00182         {\cf19 return} 1;\par
00183     \}\par
00184     {\cf19 return} 4;\par
00185 \}\par
00186 \par
00187 {\cf18 void} Pose2D::minus({\cf17 const} Pose2D other) \{\par
00188     this->x -= other.x;\par
00189     this->y -= other.y;\par
00190     this->heading -= other.heading;\par
00191 \}\par
00192 \par
00193 Pose2D Pose2D::fromPolar({\cf18 double} magnitude, {\cf18 double} angle) \{\par
00194     {\cf18 double} x = magnitude * cos(angle);\par
00195     {\cf18 double} y = magnitude * sin(angle);\par
00196     Pose2D pose(x, y, 0);\par
00197     {\cf19 return} pose;\par
00198 \}\par
00199 \par
00200 {\cf18 double} Pose2D::degreesToRadians({\cf18 double} degrees) \{\par
00201     {\cf19 return} degrees * M_PI / 180.0;\par
00202 \}\par
00203 \par
00204 Pose2D Pose2D::parseFromStream(std::istringstream& stream) \{\par
00205     {\cf18 double} x, y, heading;\par
00206         {\cf19 if} (stream >> x >> y >> heading) \{\par
00207         {\cf19 return} \{x, y, heading\};\par
00208     \}\par
00209 \par
00210     {\cf19 return} \{0, 0\};\par
00211 \}\par
00212 \par
00213 Pose2D Pose2D::subtractBy({\cf17 const} Pose2D& other){\cf17  const }\{\par
00214     {\cf19 return} \{this->x - other.x, this->y - other.y\};\par
00215 \}\par
00216 \par
00217 Pose2D Pose2D::scaleBy({\cf18 double} scalar){\cf17  const }\{\par
00218     {\cf19 return} \{this->x * scalar, this->y * scalar\};\par
00219 \}\par
00220 \par
00221 Pose2D Pose2D::normalize(){\cf17  const }\{\par
00222     {\cf18 double} squared = sqrt(pow(this->x, 2) + pow(this->y, 2));\par
00223     {\cf19 return} \{this->x / squared, this->y / squared\};\par
00224 \}\par
00225 \par
00226 {\cf18 double} Pose2D::dotProduct({\cf17 const} Pose2D& other){\cf17  const }\{\par
00227     {\cf19 return} this->x * other.x + this->y * other.y;\par
00228 \}\par
00229 \par
00230 std::ostream &operator<<(std::ostream &os, {\cf17 const} Pose2D &d) \{\par
00231     os << {\cf22 "x: "} << d.x << {\cf22 " y: "} << d.y << {\cf22 " heading: "} << d.heading;\par
00232     {\cf19 return} os;\par
00233 \}\par
00234 \par
00235 {\cf18 void} Pose2D::wrapHeading() \{\par
00236     heading = fmod(heading, 2 * M_PI);\par
00237 \par
00238     {\cf19 if} (heading > M_PI) \{\par
00239         heading -= 2 * M_PI;\par
00240     \}\par
00241 \par
00242     {\cf19 if} (heading < - M_PI) \{\par
00243         heading += 2 * M_PI;\par
00244     \}\par
00245 \}\par
00246 \par
00247 \par
00248 Rectangle makeRectangleFromLine({\cf17 const} Pose2D& L1, {\cf17 const} Pose2D& L2, {\cf18 double} width) \{\par
00249     {\cf18 double} angleBetweenPoints = L1.angleTo(L2);\par
00250     {\cf18 double} lengthBetween = L1.distanceTo(L2);\par
00251     Pose2D head(L1);\par
00252     head.setHeading(angleBetweenPoints - M_PI);\par
00253     head.translateByMagnitude(width);\par
00254     Pose2D r1(head);\par
00255     head.addAngle(M_PI);\par
00256     head.translateByMagnitude(lengthBetween);\par
00257     Pose2D r2(head);\par
00258     head.addAngle(M_PI);\par
00259     head.translateByMagnitude(width * 2);\par
00260     Pose2D r3(head);\par
00261     head.addAngle(M_PI);\par
00262     head.translateByMagnitude(lengthBetween);\par
00263     \par
00264     {\cf19 return} (Rectangle) \{r1, r2, r3, head\};\par
00265 \}\par
00266 \par
00267 {\cf18 void} Pose2D::multiply({\cf18 double} d) \{\par
00268     this->x *= d;\par
00269     this->y *= d;\par
00270 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/calebk/Documents/coding/RoombaController/src/Pose2D.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v /home/calebk/Documents/coding/RoombaController/src/Pose2D.hpp}
{\xe \v /home/calebk/Documents/coding/RoombaController/src/Pose2D.hpp}
{\bkmkstart AAAAAAAACW}
{\bkmkend AAAAAAAACW}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <cmath>}\par
{\f2 #include <cstdint>}\par
{\f2 #include <sstream>}\par
{\f2 #include <ostream>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Pose2D}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Rectangle}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BOT_RADIUS}\~ 6\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Rectangle} {\b makeRectangleFromLine} (const {\b Pose2D} &L1, const {\b Pose2D} &L2, double width)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v BOT_RADIUS\:Pose2D.hpp}
{\xe \v Pose2D.hpp\:BOT_RADIUS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BOT_RADIUS\~ 6}}
\par
{\bkmkstart AAAAAAAACX}
{\bkmkend AAAAAAAACX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The bot radius in centimeters \par
}{
Definition at line {\b 17} of file {\b Pose2D.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v makeRectangleFromLine\:Pose2D.hpp}
{\xe \v Pose2D.hpp\:makeRectangleFromLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Rectangle} makeRectangleFromLine (const {\b Pose2D} &  {\i L1}, const {\b Pose2D} &  {\i L2}, double  {\i width})}}
\par
{\bkmkstart AAAAAAAACY}
{\bkmkend AAAAAAAACY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Makes a rectangle from a line {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i L1} \cell }{One bound of the line \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i L2} \cell }{Another bound of the line \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i width} \cell }{the width of the rectangle \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
a rectangle with the the line in the middle and a width of the width passed in \par
}}}{
Definition at line {\b 248} of file {\b Pose2D.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Pose2D.hpp\par \pard\plain 
{\tc\tcl2 \v /home/calebk/Documents/coding/RoombaController/src/Pose2D.hpp}
{\xe \v /home/calebk/Documents/coding/RoombaController/src/Pose2D.hpp}
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 //}\par
00002 {\cf20 // Created by caleb on 10/24/2024}\par
00003 {\cf20 //}\par
00004 \par
00005 \par
00006 {\cf21 #ifndef POSE2D_H}\par
00007 {\cf21 #define POSE2D_H}\par
00008 \par
00009 {\cf21 #include <cmath>}\par
00010 {\cf21 #include <cstdint>}\par
00011 {\cf21 #include <sstream>}\par
00012 {\cf21 #include <ostream>}\par
00013 \par
00017 {\cf21 #define BOT_RADIUS 6}\par
00018 \par
00023 {\cf17 class }Pose2D \{\par
00024   {\cf17 protected}:\par
00025     {\cf18 double} x, y, heading;\par
00026 \par
00027   {\cf17 public}:\par
00034     Pose2D({\cf18 double} x, {\cf18 double} y, {\cf18 double} heading);\par
00035 \par
00041     Pose2D({\cf18 double} x, {\cf18 double} y);\par
00042 \par
00046     Pose2D();\par
00047 \par
00053     Pose2D({\cf17 const} Pose2D& position);\par
00054     {\cf20 // Pose2D(Pose2D* position);}\par
00060     [[nodiscard]] {\cf18 double} angleTo({\cf17 const} Pose2D& other) {\cf17 const};\par
00061 \par
00067     [[nodiscard]] {\cf18 double} distanceTo({\cf17 const} Pose2D& other) {\cf17 const};\par
00068 \par
00074     [[nodiscard]] {\cf18 double} squareOfDistanceTo({\cf17 const} Pose2D& other) {\cf17 const};\par
00075 \par
00082     {\cf17 static} Pose2D fromPolar({\cf18 double} magnitude, {\cf18 double} angle);\par
00083 \par
00089     {\cf17 static} {\cf18 double} degreesToRadians({\cf18 double} degrees);\par
00090 \par
00096     {\cf17 static} {\cf18 double} radiansToDegrees({\cf18 double} radians);\par
00097 \par
00102     [[nodiscard]] Pose2D clone() {\cf17 const};\par
00103 \par
00108     {\cf18 void} rotateByPose({\cf17 const} Pose2D& rotation);\par
00109 \par
00115     {\cf18 void} rotateByAngle({\cf18 double} angle);\par
00116 \par
00122     {\cf18 void} translateByPose({\cf17 const} Pose2D& translation);\par
00123 \par
00131     {\cf18 void} translateByMagnitude({\cf18 double} magnitude);\par
00132 \par
00137     {\cf18 void} transformPose({\cf17 const} Pose2D& modifier);\par
00138 \par
00143     [[nodiscard]] {\cf18 double} getX() {\cf17 const};\par
00144 \par
00149     [[nodiscard]] {\cf18 double} getY() {\cf17 const};\par
00150 \par
00155     [[nodiscard]] {\cf18 double} getHeading() {\cf17 const};\par
00156 \par
00161     {\cf18 void} setHeading({\cf18 double} angle);\par
00162 \par
00167     {\cf18 void} plusCoord({\cf17 const} Pose2D& other);\par
00168 \par
00174     {\cf18 void} plus({\cf17 const} Pose2D& other);\par
00175 \par
00181     {\cf18 void} minus(Pose2D other);\par
00182 \par
00187     {\cf18 void} addAngle({\cf18 double} angle);\par
00188 \par
00194     [[nodiscard]] Pose2D subtractBy({\cf17 const} Pose2D& other) {\cf17 const};\par
00195 \par
00201     [[nodiscard]] Pose2D scaleBy({\cf18 double} scaler) {\cf17 const};\par
00202 \par
00207     [[nodiscard]] Pose2D normalize() {\cf17 const};\par
00208 \par
00214     [[nodiscard]] {\cf18 double} dotProduct({\cf17 const} Pose2D& other) {\cf17 const};\par
00215 \par
00222     {\cf17 friend} std::ostream &operator<<(std::ostream &os, {\cf17 const} Pose2D &d);\par
00223 \par
00228     {\cf18 void} setX({\cf18 double} x);\par
00229 \par
00235     {\cf18 void} vecAdd({\cf18 double} angle, {\cf18 double} magnitude);\par
00236 \par
00241     {\cf18 void} setY({\cf18 double} y);\par
00242 \par
00254     [[nodiscard]] uint8_t getQuadrant() {\cf17 const};\par
00255 \par
00259     {\cf18 void} wrapHeading();\par
00260 \par
00265     {\cf18 void} transformForPose({\cf17 const} Pose2D& other);\par
00266 \par
00272     {\cf17 static} Pose2D parseFromStream(std::istringstream& stream);\par
00273 \par
00280     {\cf20 // static SlopeIntercept getSlopeIntercept(Pose2D one, Pose2D two);}\par
00281     \par
00282 \par
00288     {\cf18 bool} isOnLine(Pose2D LineEnd1, Pose2D LineEnd2);\par
00289 \par
00293     {\cf18 bool} isPerpendicularToLine({\cf18 double} m);\par
00294 \par
00302     {\cf17 static} {\cf18 double} getAngleBetweenPoints(Pose2D corner, Pose2D end1, Pose2D end2);\par
00303 \par
00307     {\cf18 void} multiply({\cf18 double} d);\par
00308 \};\par
00309 \par
00313 {\cf17 struct }Rectangle \{\par
00314     Pose2D r1, r2, r3, r4;\par
00315 \};\par
00316 \par
00324 Rectangle makeRectangleFromLine({\cf17 const} Pose2D& L1, {\cf17 const} Pose2D& L2, {\cf18 double} width);\par
00325 \par
00326 {\cf21 #endif }{\cf20 //POSE2D_H}\par
00327 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/calebk/Documents/coding/RoombaController/src/util.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /home/calebk/Documents/coding/RoombaController/src/util.cpp}
{\xe \v /home/calebk/Documents/coding/RoombaController/src/util.cpp}
{\bkmkstart AAAAAAAACZ}
{\bkmkend AAAAAAAACZ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "util.hpp"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b orientation} (double px, double py, double qx, double qy, double rx, double ry)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b onSegment} (double px, double py, double qx, double qy, double rx, double ry)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b doIntersect} (double p1x, double p1y, double q1x, double q1y, double p2x, double p2y, double q2x, double q2y)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b lineIntersectsRectangle} (double cx1, double cy1, double cx2, double cy2, double rx1, double ry1, double rx2, double ry2, double rx3, double ry3, double rx4, double ry4)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v doIntersect\:util.cpp}
{\xe \v util.cpp\:doIntersect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool doIntersect (double  {\i p1x}, double  {\i p1y}, double  {\i q1x}, double  {\i q1y}, double  {\i p2x}, double  {\i p2y}, double  {\i q2x}, double  {\i q2y})}}
\par
{\bkmkstart AAAAAAAADA}
{\bkmkend AAAAAAAADA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 18} of file {\b util.cpp}.}\par
}
{\xe \v lineIntersectsRectangle\:util.cpp}
{\xe \v util.cpp\:lineIntersectsRectangle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool lineIntersectsRectangle (double  {\i cx1}, double  {\i cy1}, double  {\i cx2}, double  {\i cy2}, double  {\i rx1}, double  {\i ry1}, double  {\i rx2}, double  {\i ry2}, double  {\i rx3}, double  {\i ry3}, double  {\i rx4}, double  {\i ry4})}}
\par
{\bkmkstart AAAAAAAADB}
{\bkmkend AAAAAAAADB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 46} of file {\b util.cpp}.}\par
}
{\xe \v onSegment\:util.cpp}
{\xe \v util.cpp\:onSegment}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool onSegment (double  {\i px}, double  {\i py}, double  {\i qx}, double  {\i qy}, double  {\i rx}, double  {\i ry})}}
\par
{\bkmkstart AAAAAAAADC}
{\bkmkend AAAAAAAADC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 13} of file {\b util.cpp}.}\par
}
{\xe \v orientation\:util.cpp}
{\xe \v util.cpp\:orientation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double orientation (double  {\i px}, double  {\i py}, double  {\i qx}, double  {\i qy}, double  {\i rx}, double  {\i ry})}}
\par
{\bkmkstart AAAAAAAADD}
{\bkmkend AAAAAAAADD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Created by Caleb Kugel 11/21/2024 \par
}{
Definition at line {\b 7} of file {\b util.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
util.cpp\par \pard\plain 
{\tc\tcl2 \v /home/calebk/Documents/coding/RoombaController/src/util.cpp}
{\xe \v /home/calebk/Documents/coding/RoombaController/src/util.cpp}
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00005 {\cf21 #include "util.hpp"}\par
00006 \par
00007 {\cf18 double} orientation({\cf18 double} px, {\cf18 double} py, {\cf18 double} qx, {\cf18 double} qy, {\cf18 double} rx, {\cf18 double} ry) \{\par
00008     {\cf18 double} val = (qy - py) * (rx - qx) - (qx - px) * (ry - qy);\par
00009     {\cf19 if} (fabs(val) < 0.1) {\cf19 return} 0; {\cf20 // collinear}\par
00010     {\cf19 return} (val > 0) ? 1 : 2; {\cf20 // clockwise or counterclockwise}\par
00011 \}\par
00012 \par
00013 {\cf18 bool} onSegment({\cf18 double} px, {\cf18 double} py, {\cf18 double} qx, {\cf18 double} qy, {\cf18 double} rx, {\cf18 double} ry) \{\par
00014     {\cf19 return} qx <= (px > rx ? px : rx) && qx >= (px < rx ? px : rx) &&\par
00015            qy <= (py > ry ? py : ry) && qy >= (py < ry ? py : ry);\par
00016 \}\par
00017 \par
00018 {\cf18 bool} doIntersect({\cf18 double} p1x, {\cf18 double} p1y, {\cf18 double} q1x, {\cf18 double} q1y, {\cf18 double} p2x, {\cf18 double} p2y, {\cf18 double} q2x, {\cf18 double} q2y) \{\par
00019     {\cf18 double} o1 = orientation(p1x, p1y, q1x, q1y, p2x, p2y);\par
00020     {\cf18 double} o2 = orientation(p1x, p1y, q1x, q1y, q2x, q2y);\par
00021     {\cf18 double} o3 = orientation(p2x, p2y, q2x, q2y, p1x, p1y);\par
00022     {\cf18 double} o4 = orientation(p2x, p2y, q2x, q2y, q1x, q1y);\par
00023 \par
00024     {\cf20 // standard case}\par
00025     {\cf19 if} (o1 != o2 && o3 != o4) {\cf19 return} {\cf17 true};\par
00026 \par
00027     {\cf20 // Edge cases}\par
00028     {\cf20 // p1, q1, p2 are collinear and p2 lies on segment p1q1}\par
00029     {\cf19 if} (o1 == 0 && onSegment(p1x, p1y, p2x, p2y, q1x, q1y)) {\cf19 return} {\cf17 true};\par
00030 \par
00031     {\cf20 // p1, q1, q2 are collinear and q2 lies on segment p1q1}\par
00032     {\cf19 if} (o2 == 0 && onSegment(p1x, p1y, q2x, q2y, q1x, q1y)) {\cf19 return} {\cf17 true};\par
00033 \par
00034     {\cf20 // p2, q2, p1 are collinear and p1 lies on segment p2q2}\par
00035     {\cf19 if} (o3 == 0 && onSegment(p2x, p2y, p1x, p1y, q2x, q2y)) {\cf19 return} {\cf17 true};\par
00036 \par
00037     {\cf20 // p2, q2, q1 are collinear and q1 lies on segment p2q2}\par
00038     {\cf19 if} (o4 == 0 && onSegment(p2x, p2y, q1x, q1y, q2x, q2y)) {\cf19 return} {\cf17 true};\par
00039 \par
00040     {\cf19 return} {\cf17 false}; {\cf20 // No doubleersection}\par
00041 \}\par
00042 \par
00043 \par
00044 \par
00045 \par
00046 {\cf18 bool} lineIntersectsRectangle({\cf18 double} cx1, {\cf18 double} cy1, {\cf18 double} cx2, {\cf18 double} cy2, {\cf18 double} rx1, {\cf18 double} ry1, {\cf18 double} rx2, {\cf18 double} ry2, {\cf18 double} rx3, {\cf18 double} ry3, {\cf18 double} rx4, {\cf18 double} ry4) \{\par
00047     {\cf20 // Check if the line intersects any of the rectangle's edges}\par
00048     {\cf19 return} doIntersect(cx1, cy1, cx2, cy2, rx1, ry1, rx2, ry2) || doIntersect(cx1, cy1, cx2, cy2, rx2, ry2, rx3, ry3) || doIntersect(cx1, cy1, cx2, cy2, rx3, ry3, rx4, ry4) || doIntersect(cx1, cy1, cx2, cy2, rx4, ry4, rx1, ry1);\par
00049 \}\par
00050 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/home/calebk/Documents/coding/RoombaController/src/util.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v /home/calebk/Documents/coding/RoombaController/src/util.hpp}
{\xe \v /home/calebk/Documents/coding/RoombaController/src/util.hpp}
{\bkmkstart AAAAAAAADE}
{\bkmkend AAAAAAAADE}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <cmath>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b orientation} (double px2, double py, double qx, double qy, double rx, double ry)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b onSegment} (double px, double py, double qx, double qy, double rx, double ry)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b doIntersect} (double p1x, double p1y, double q1x, double q1y, double p2x, double p2y, double q2x, double q2y)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b lineIntersectsRectangle} (double cx1, double cy1, double cx2, double cy2, double rx1, double ry1, double rx2, double ry2, double rx3, double ry3, double rx4, double ry4)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v doIntersect\:util.hpp}
{\xe \v util.hpp\:doIntersect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool doIntersect (double  {\i p1x}, double  {\i p1y}, double  {\i q1x}, double  {\i q1y}, double  {\i p2x}, double  {\i p2y}, double  {\i q2x}, double  {\i q2y})}}
\par
{\bkmkstart AAAAAAAADF}
{\bkmkend AAAAAAAADF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 18} of file {\b util.cpp}.}\par
}
{\xe \v lineIntersectsRectangle\:util.hpp}
{\xe \v util.hpp\:lineIntersectsRectangle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool lineIntersectsRectangle (double  {\i cx1}, double  {\i cy1}, double  {\i cx2}, double  {\i cy2}, double  {\i rx1}, double  {\i ry1}, double  {\i rx2}, double  {\i ry2}, double  {\i rx3}, double  {\i ry3}, double  {\i rx4}, double  {\i ry4})}}
\par
{\bkmkstart AAAAAAAADG}
{\bkmkend AAAAAAAADG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 46} of file {\b util.cpp}.}\par
}
{\xe \v onSegment\:util.hpp}
{\xe \v util.hpp\:onSegment}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool onSegment (double  {\i px}, double  {\i py}, double  {\i qx}, double  {\i qy}, double  {\i rx}, double  {\i ry})}}
\par
{\bkmkstart AAAAAAAADH}
{\bkmkend AAAAAAAADH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 13} of file {\b util.cpp}.}\par
}
{\xe \v orientation\:util.hpp}
{\xe \v util.hpp\:orientation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double orientation (double  {\i px}, double  {\i py}, double  {\i qx}, double  {\i qy}, double  {\i rx}, double  {\i ry})}}
\par
{\bkmkstart AAAAAAAADI}
{\bkmkend AAAAAAAADI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Created by Caleb Kugel 11/21/2024 \par
}{
Definition at line {\b 7} of file {\b util.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
util.hpp\par \pard\plain 
{\tc\tcl2 \v /home/calebk/Documents/coding/RoombaController/src/util.hpp}
{\xe \v /home/calebk/Documents/coding/RoombaController/src/util.hpp}
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
Go to the documentation of this file.\par
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00005 {\cf21 #ifndef UTIL_H}\par
00006 {\cf21 #define UTIL_H}\par
00007 \par
00008 {\cf21 #include <cmath>}\par
00009 \par
00010 \par
00011 {\cf20 /*}\par
00012 {\cf20  * calculates the orientation of the ordered triplet (p, q, r)}\par
00013 {\cf20 * @return}\par
00014 {\cf20     * 0 -> p, q, r are collinear}\par
00015 {\cf20     * 1 -> Clockwise}\par
00016 {\cf20     * 2 -> Counterclockwise}\par
00017 {\cf20 */}\par
00018 {\cf18 double} orientation({\cf18 double} px2, {\cf18 double} py, {\cf18 double} qx, {\cf18 double} qy, {\cf18 double} rx, {\cf18 double} ry);\par
00019 \par
00020 \par
00021 {\cf20 /*}\par
00022 {\cf20  * checks if point q lies on the line segment 'pr'}\par
00023 {\cf20 */}\par
00024 {\cf18 bool} onSegment({\cf18 double} px, {\cf18 double} py, {\cf18 double} qx, {\cf18 double} qy, {\cf18 double} rx, {\cf18 double} ry);\par
00025 \par
00026 \par
00027 {\cf20 /*}\par
00028 {\cf20  * determines if line segments (p1, q1) and (p2, q2) intersect}\par
00029 {\cf20 */}\par
00030 {\cf18 bool} doIntersect({\cf18 double} p1x, {\cf18 double} p1y, {\cf18 double} q1x, {\cf18 double} q1y, {\cf18 double} p2x, {\cf18 double} p2y, {\cf18 double} q2x, {\cf18 double} q2y);\par
00031 \par
00032 {\cf20 /*}\par
00033 {\cf20 * function to check if the line intersects a given rectangle}\par
00034 {\cf20 * @param cx1 the x position of the first bound of the line}\par
00035 {\cf20 * @param cy1 the y position of the first bound of the line}\par
00036 {\cf20 * @param cx2 the x position of the second bound of the line}\par
00037 {\cf20 * @param cy2 the y position of the second bound of the line}\par
00038 {\cf20 * @param rx1 the x position of the first rectangular X coordinate}\par
00039 {\cf20 * @param ry1 the y position of the first rectangular Y coordinate}\par
00040 {\cf20 * @param rx2 the x position of the second rectangular X coordinate}\par
00041 {\cf20 * @param ry2 the y position of the second rectangular Y coordinate}\par
00042 {\cf20 * @param rx3 the x position of the third rectangular X coordinate}\par
00043 {\cf20 * @param ry3 the y position of the third rectangular Y coordinate}\par
00044 {\cf20 * @param rx4 the x position of the fourth rectangular X coordinate}\par
00045 {\cf20 * @param ry4 the y position of the fourth rectangular Y coordinate}\par
00046 {\cf20 * @return whether the line intersects the position}\par
00047 {\cf20 */}\par
00048 {\cf18 bool} lineIntersectsRectangle({\cf18 double} cx1, {\cf18 double} cy1, {\cf18 double} cx2, {\cf18 double} cy2, {\cf18 double} rx1, {\cf18 double} ry1, {\cf18 double} rx2, {\cf18 double} ry2, {\cf18 double} rx3, {\cf18 double} ry3, {\cf18 double} rx4, {\cf18 double} ry4);\par
00049 \par
00050 \par
00051 \par
00052 {\cf21 #endif }{\cf20 // UTIL_H}\par
00053 \par
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Index\par 
\pard\plain 
{\tc \v Index}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}
